---
title: "MC1"
date: "Jun 01, 2025"
date-modified: "last-modified"
author: "Ng Jin Yao"
format: 
  html:
    code-fold: true
    code-tools: true
editor: visual
execute: 
  eval: true
  echo: true
  warning: false
  freeze: true
---

::: callout-important
## Important

You are required to install the R packages above, if necessary, before continue to the next step\
Check packages to ensure they are installed
:::

## Loading Libraries

```{r}
pacman::p_load(tidyverse, jsonlite, 
               SmartEDA, tidygraph, 
               ggraph,dplyr,igraph, visNetwork)

```

::: callout-note
## The Question

1.  Design and develop visualizations and visual analytic tools that will allow Silas to explore and understand the profile of Sailor Shiftâ€™s career

    1.  Who has she been most influenced by over time?

    2.  Who has she collaborated with and directly or indirectly influenced?

    3.  How has she influenced collaborators of the broader Oceanus Folk community?
:::

## Data Cleaning and Initial analysis:

### Show data cleaning and checking

## Who has she been most influenced by over time?

### Graph showing who she take influence from

### sub graph showing top 3 people she take influence from

## Who has she collaborated with and directly or indirectly influenced?

### Graph showing who she influenced

### Focused sub graph showing top 3 people taking influence from her

## How has she influenced collaborators of the broader Oceanus Folk Community

## Visnetwork graph

plotting a visnetwork graph to visualise the interactions centering around sailor shift

### Step 1 :

### Load Libraries

```         
```

### Loading and working on Json Raw Data

```{r}
# --- 1. Load your JSON data ---
kg <- fromJSON("data/MC1_graph.json")

```

#### Check the structure of the data

```{r}
str(kg,max.level = 1)
#structure enable to check structure of the data
#good to have this line to check structues of data
```

#### Extract and inspect the nodes and edges

```{r}
nodes_tbl <- as_tibble(kg$nodes)
edges_tbl <- as_tibble(kg$links)
```

#### Initial Exploratory Data Analysis

Using the code blocks below we can check the types of edges and nodes in the dataset:

```{r}
ggplot(data = edges_tbl,
       aes(y= `Edge Type`)) +
  geom_bar()

ggplot(data = nodes_tbl,
       aes(y= `Node Type`)) +
  geom_bar()
```

```{r}
# --- 2. Exploratory Data Analysis for nodes_tbl ---
cat("\n--- Nodes Table (nodes_tbl) EDA ---\n")

# A. Dimensions
cat("\nDimensions (Rows x Columns):", paste(dim(nodes_tbl), collapse = " x "), "\n")

# B. Column Names and Types
cat("\nColumn Names and Data Types:\n")
print(nodes_tbl %>% summarise_all(class)) # This shows class of each column
# For a more detailed look:
# glimpse(nodes_tbl)

# C. Missing Values Overview
cat("\nMissing Values (Count and Percentage per Column):\n")
missing_nodes <- nodes_tbl %>%
  summarise_all(~ sum(is.na(.))) %>%
  tidyr::pivot_longer(everything(), names_to = "column", values_to = "na_count") %>%
  mutate(na_pct = (na_count / nrow(nodes_tbl)) * 100)
print(missing_nodes %>% arrange(desc(na_count)))

# D. Unique ID Checks
cat("\nUnique ID Check for 'id' column:\n")
cat("Number of unique IDs:", n_distinct(nodes_tbl$id), "\n")
cat("Total number of rows:", nrow(nodes_tbl), "\n")
if (n_distinct(nodes_tbl$id) == nrow(nodes_tbl)) {
  cat("All 'id' values are unique.\n")
} else {
  cat("Warning: Duplicate 'id' values found! (", nrow(nodes_tbl) - n_distinct(nodes_tbl$id), "duplicates)\n")
  # To see duplicates:
  # nodes_tbl %>% count(id) %>% filter(n > 1) %>% arrange(desc(n))
}

# E. Categorical Column Summaries
cat("\nSummary for Categorical Columns:\n")

# 'Node Type'
cat("\n'Node Type' distribution:\n")
print(nodes_tbl %>% count(`Node Type`, sort = TRUE, name = "count") %>%
        mutate(percentage = (count / sum(count)) * 100))

# 'name' (checking for empty strings or highly similar names)
cat("\nTop 10 Most Frequent 'name' values (and count of empty/NA names):\n")
nodes_tbl %>%
  mutate(clean_name = ifelse(is.na(name), "[NA]", ifelse(str_trim(name) == "", "[EMPTY]", name))) %>%
  count(clean_name, sort = TRUE) %>%
  head(10) %>% print()
cat("Number of empty string names:", sum(str_trim(nodes_tbl$name) == "" & !is.na(nodes_tbl$name)), "\n")


# 'genre' (if it exists)
if ("genre" %in% names(nodes_tbl)) {
  cat("\n'genre' distribution (Top 10):\n")
  print(nodes_tbl %>% count(genre, sort = TRUE, name = "count") %>%
          mutate(percentage = (count / sum(count)) * 100) %>% head(10))
  cat("Number of NA genres:", sum(is.na(nodes_tbl$genre)), "\n")
} else {
  cat("\n'genre' column not found in nodes_tbl.\n")
}

# 'notable' (if it exists)
if ("notable" %in% names(nodes_tbl)) {
  cat("\n'notable' distribution:\n")
  print(nodes_tbl %>% count(notable, sort = TRUE, name = "count") %>%
          mutate(percentage = (count / sum(count)) * 100))
  cat("Number of NA 'notable' values:", sum(is.na(nodes_tbl$notable)), "\n")
} else {
  cat("\n'notable' column not found in nodes_tbl.\n")
}


# F. Date Column Summaries ('release_date', 'notoriety_date')
cat("\nSummary for Date Columns:\n")

# 'release_date'
if ("release_date" %in% names(nodes_tbl)) {
  cat("\n'release_date' overview:\n")
  nodes_tbl_dates <- nodes_tbl %>%
    mutate(parsed_release_date = ymd(release_date, quiet = TRUE)) # Attempt to parse

  cat("Number of NA 'release_date' values:", sum(is.na(nodes_tbl$release_date)), "\n")
  cat("Number of unparseable 'release_date' values:", sum(is.na(nodes_tbl_dates$parsed_release_date) & !is.na(nodes_tbl$release_date)), "\n")
  cat("Min parsed release date:", min(nodes_tbl_dates$parsed_release_date, na.rm = TRUE), "\n")
  cat("Max parsed release date:", max(nodes_tbl_dates$parsed_release_date, na.rm = TRUE), "\n")
} else {
  cat("\n'release_date' column not found in nodes_tbl.\n")
}

# 'notoriety_date'
if ("notoriety_date" %in% names(nodes_tbl)) {
  cat("\n'notoriety_date' overview:\n")
  nodes_tbl_dates <- nodes_tbl %>%
    mutate(parsed_notoriety_date = ymd(notoriety_date, quiet = TRUE)) # Attempt to parse

  cat("Number of NA 'notoriety_date' values:", sum(is.na(nodes_tbl$notoriety_date)), "\n")
  cat("Number of unparseable 'notoriety_date' values:", sum(is.na(nodes_tbl_dates$parsed_notoriety_date) & !is.na(nodes_tbl$notoriety_date)), "\n")
  cat("Min parsed notoriety date:", min(nodes_tbl_dates$parsed_notoriety_date, na.rm = TRUE), "\n")
  cat("Max parsed notoriety date:", max(nodes_tbl_dates$parsed_notoriety_date, na.rm = TRUE), "\n")
} else {
  cat("\n'notoriety_date' column not found in nodes_tbl.\n")
}


# --- 3. Exploratory Data Analysis for edges_tbl ---
cat("\n\n--- Edges Table (edges_tbl) EDA ---\n")

# A. Dimensions
cat("\nDimensions (Rows x Columns):", paste(dim(edges_tbl), collapse = " x "), "\n")

# B. Column Names and Types
cat("\nColumn Names and Data Types:\n")
print(edges_tbl %>% summarise_all(class))
# glimpse(edges_tbl)

# C. Missing Values Overview
cat("\nMissing Values (Count and Percentage per Column):\n")
missing_edges <- edges_tbl %>%
  summarise_all(~ sum(is.na(.))) %>%
  tidyr::pivot_longer(everything(), names_to = "column", values_to = "na_count") %>%
  mutate(na_pct = (na_count / nrow(edges_tbl)) * 100)
print(missing_edges %>% arrange(desc(na_count)))

# D. Source/Target ID Checks
cat("\nSource and Target ID Checks:\n")
cat("Number of unique 'source' IDs:", n_distinct(edges_tbl$source), "\n")
cat("Number of unique 'target' IDs:", n_distinct(edges_tbl$target), "\n")

# Check if all source/target IDs exist in nodes_tbl
nodes_ids <- nodes_tbl$id

invalid_source_ids <- edges_tbl %>% filter(!(source %in% nodes_ids)) %>% pull(source) %>% unique()
invalid_target_ids <- edges_tbl %>% filter(!(target %in% nodes_ids)) %>% pull(target) %>% unique()

if (length(invalid_source_ids) > 0) {
  cat("Warning: Found", length(invalid_source_ids), "source IDs not present in nodes_tbl (e.g.,", head(invalid_source_ids, 5), ").\n")
} else {
  cat("All 'source' IDs are present in nodes_tbl.\n")
}

if (length(invalid_target_ids) > 0) {
  cat("Warning: Found", length(invalid_target_ids), "target IDs not present in nodes_tbl (e.g.,", head(invalid_target_ids, 5), ").\n")
} else {
  cat("All 'target' IDs are present in nodes_tbl.\n")
}

# E. Categorical Column Summaries
cat("\nSummary for Categorical Columns:\n")

# 'Edge Type'
cat("\n'Edge Type' distribution:\n")
print(edges_tbl %>% count(`Edge Type`, sort = TRUE, name = "count") %>%
        mutate(percentage = (count / sum(count)) * 100))

# 'key' (if it exists)
if ("key" %in% names(edges_tbl)) {
  cat("\n'key' uniqueness check:\n")
  cat("Number of unique 'key' values:", n_distinct(edges_tbl$key), "\n")
  cat("Total number of edges:", nrow(edges_tbl), "\n")
  if (n_distinct(edges_tbl$key) == nrow(edges_tbl)) {
    cat("All 'key' values are unique (good for identifying individual edges).\n")
  } else {
    cat("Warning: Duplicate 'key' values found! (", nrow(edges_tbl) - n_distinct(edges_tbl$key), "duplicates)\n")
    # To see duplicates:
    # edges_tbl %>% count(key) %>% filter(n > 1) %>% arrange(desc(n))
  }
} else {
  cat("\n'key' column not found in edges_tbl.\n")
}

cat("\n--- EDA Complete ---\n")
```

#### Defining and Standardizing Node and Edge Colors

In order to ensure the graphs generated later on have standardized colors. We will need to define them in this code block here:

```{r}
# --- Define ALL possible Node Type Colors (Global and Consistent) ---
# all_node_type_colors <- c(
#   "Song" = "lightblue",
#   "Person" = "orange",
#   "MusicalGroup" = "#CF9FFF",
#   "RecordLabel" = "lightgreen",
#   "default" = "gray" # Fallback color for any unlisted type
# )
# 
# # --- Define ALL possible Edge Type Colors (Global and Consistent) ---
# all_edge_type_colors <- c(
#   "PerformerOf" = "#FF5733",
#   "ComposerOf" = "#33FF57",
#   "ProducerOf" = "#3357FF",
#   "LyricistOf" = "#FF33F5",
#   "RecordedBy" = "#F5FF33",
#   "InterpolatesFrom" = "#8A2BE2",
#   "InStyleOf" = "#DAA520",
#   "LyricalReferenceTo" = "#5F9EA0",
#   "CoverOf" = "#DC143C",
#   "DirectlySamples" = "#6A5ACD",
#   "DistributedBy" = "#20B2AA",
#   "MemberOf" = "#8B4513",
#   "default" = "#CCCCCC" # Fallback color for any unlisted type
# )


all_node_type_colors <- c(
  "Song" = "lightblue",
  "Album" = "brown",
  "Person" = "orange",
  "MusicalGroup" = "purple",
  "RecordLabel" = "lightgreen",
  "Unknown" = "gray"
)

all_edge_type_colors <- c(
  "PerformerOf" = "#FF5733", 
  "ComposerOf" = "#33FF57",
  "ProducerOf" = "#3357FF",
  "LyricistOf" = "#FF33F5",
  "RecordedBy" = "#F5FF33", 
  "InterpolatesFrom" = "#8A2BE2",
  "InStyleOf" = "#DAA520", 
  "LyricalReferenceTo" = "#5F9EA0", 
  "CoverOf" = "#DC143C",
  "DirectlySamples" = "#6A5ACD",
  "DistributedBy" = "#20B2AA", 
  "MemberOf" = "#8B4513",
  "default" = "#CCCCCC"
)
```

#### Data Preparation for visNetwork

### Set filter and no. of hops

```{r}
# --- Configuration ---
target_name <- "Sailor Shift"
max_hops_for_context <- 3
```

### Select target node ID

```{r}
# --- Get target node ID ---
sailor_node <- nodes_tbl %>% filter(name == target_name)
if (nrow(sailor_node) == 0) stop(paste("No node named '", target_name, "' found.", sep=""))
sailor_id <- as.character(sailor_node$id)
```

### Preparing edges df for filtering and visnetwork

```{r}
# --- Prepare edges_igraph_df for filtering and visNetwork ---
edges_igraph_df <- edges_tbl %>%
  select(source, target, `Edge Type`, key) %>%
  mutate(across(c(source, target), as.character)) %>%
  rename(from = source, to = target) # Rename to from/to for visNetwork
```

### data preparation for visNetwork

```{r}
# --- Section 1: General Context Network (2-hop) ---
# Build igraph for neighborhood calculation
g <- graph_from_data_frame(edges_igraph_df, directed = FALSE)

```

```{r}
# Get N-hop neighborhood for general context
ego_nodes_indices <- ego(graph = g, order = max_hops_for_context, nodes = sailor_id, mode = "all")[[1]]
connected_ids_general <- names(ego_nodes_indices)
```

```{r}
# Filter nodes for the general context subgraph
sub_nodes_general <- nodes_tbl %>%
  filter(as.character(id) %in% connected_ids_general) %>%
  mutate(
    id = as.character(id),
    label = name,
    stage_name_str = if_else(!is.na(stage_name), paste0("<b>Stage Name:</b> ", stage_name, "<br>"), ""),
    release_date_str = if_else(!is.na(release_date), paste0("<b>Release Date:</b> ", release_date, "<br>"), ""),
    # Include genre information for the tooltip
    genre_str = if_else(!is.na(genre), paste0("<b>Genre:</b> ", genre, "<br>"), ""),
    notable_str = if_else(!is.na(notable), paste0("<b>Notable:</b> ", notable, "<br>"), ""),
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      genre_str, # Add genre to the tooltip
      stage_name_str,
      release_date_str,
      notable_str
    ),
    group = `Node Type`,
    # --- ADD THIS LINE TO CONTROL NODE SIZE ---
    size = ifelse(id == sailor_id, 50, 15) # Sailor Shift size 50, others 15
  ) %>%
  select(-stage_name_str, -release_date_str, -genre_str, -notable_str)
```

```{r}
# Filter edges for the general context subgraph and add color
sub_edges_general <- edges_igraph_df %>%
  filter(from %in% sub_nodes_general$id & to %in% sub_nodes_general$id) %>%
  mutate(color = all_edge_type_colors[`Edge Type`])
sub_edges_general$color[is.na(sub_edges_general$color)] <- all_edge_type_colors["default"]

```

### Generating Visnetwork graph for exploration

```{r}
# Visualize General Context Network
graph_general_context <- visNetwork(nodes = sub_nodes_general, edges = sub_edges_general,
                                    main = paste0("'", target_name, "' Network (", max_hops_for_context, "-hop Context)")) %>%
  visNodes(shape = "dot", size = 15, label = ~label, title = ~title) %>%
  visEdges(
    arrows = "to",
    label = ~`Edge Type`,
    font = list(size = 10, align = "middle"),
    color = list(color = ~color, highlight = ~color)
  ) %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = list(enabled = TRUE, selected = sailor_id)) %>%
  # Define node groups and their colors explicitly (needed for visLegend)
  visGroups(groupname = "Song", color = "lightblue") %>%
  visGroups(groupname = "Person", color = "orange") %>%
  visGroups(groupname = "RecordLabel", color = "lightgreen") %>%
  # Separate legend for nodes (on the left)
  visLegend(
    main = "all_node_type_colors",
    useGroups = TRUE, # Show node groups in this legend
    position = "left",
    width = 0.15 # Adjust width as needed
  ) %>%
  # # Separate legend for edges (on the right)
  # visLegend(
  #   main = "Edge Types",
  #   # Do not use useGroups or useEdges here as we are manually adding edges
  #   addEdges = data.frame(
  #     color = unname(all_edge_type_colors),
  #     label = names(all_edge_type_colors),
  #     font.align = "top" # Or "middle", "bottom"
  #   ),
  #   position = "right",
  #   width = 0.15 # Adjust width as needed
  # ) %>%
  visIgraphLayout(layout = "layout_with_fr", randomSeed = 42)%>% # Apply FR layout
  visOptions(selectedBy = "group", 
             highlightNearest = TRUE, 
             nodesIdSelection = TRUE)

graph_general_context

```

### Optional - save as a html to view

```{r}
#| eval: false
visSave(graph_general_context, file = paste0(target_name, "_general_network_", max_hops_for_context, "hop.html"))
```

## visNetwork graph to explore Sailor Shift connections to other Persons or musical groups

able to see that a cluster of them are linked to sailor shift - dive deeper in following graphs

```{r}
# --- Library Loading ---
library(dplyr)
library(jsonlite)
library(igraph) # Often needed implicitly by visNetwork layouts
library(visNetwork)
library(stringr) # For string trimming

# --- Global Color Definitions (Moved up for clarity and reuse) ---
  

# Helper function for HTML details in tooltips
get_html_detail <- function(value, label) {
  if (!is.null(value) && !is.na(value) && as.character(value) != "") {
    return(paste0("<b>", label, ":</b> ", as.character(value), "<br>"))
  }
  return("")
}


# --- 1. Load your JSON data ---
tryCatch({
  kg <- fromJSON("data/MC1_graph.json")
  nodes_tbl <- as_tibble(kg$nodes)
  edges_tbl <- as_tibble(kg$links)
  message("Data loaded successfully.")
}, error = function(e) {
  stop(paste("Error loading 'MC1_graph.json': ", e$message, "\nPlease ensure the file is in 'data/MC1_graph.json' relative to your working directory."))
})

# --- Configuration ---
target_name <- "Sailor Shift"

# --- Define the specific edge types for this new visualization ---
desired_edge_types_for_group_interactions <- c(
  "InterpolatesFrom",
  "DirectlySamples",
  "InStyleOf",
  "CoverOf",
  "LyricalReferenceTo",
  "MemberOf"
)

# --- IMPORTANT: Strict Node ID Cleaning ---
nodes_tbl_cleaned <- nodes_tbl %>%
  mutate(id = as.character(id)) %>%
  mutate(id = trimws(id)) %>%
  filter(!is.na(id) & id != "") %>%
  mutate(`Node Type` = trimws(ifelse(is.na(`Node Type`), "Unknown", as.character(`Node Type`)))) %>%
  distinct(id, .keep_all = TRUE)

# --- Add missing columns with NA if they don't exist, before mutations ---
if (!"stage_name" %in% names(nodes_tbl_cleaned)) nodes_tbl_cleaned$stage_name <- NA_character_
if (!"release_date" %in% names(nodes_tbl_cleaned)) nodes_tbl_cleaned$release_date <- NA_character_
if (!"genre" %in% names(nodes_tbl_cleaned)) nodes_tbl_cleaned$genre <- NA_character_
if (!"notable" %in% names(nodes_tbl_cleaned)) nodes_tbl_cleaned$notable <- NA # Logical NA for boolean column


# --- Get target node ID ---
sailor_node <- nodes_tbl_cleaned %>% filter(name == target_name)
if (nrow(sailor_node) == 0) stop(paste("No node named '", target_name, "' found in cleaned data.", sep=""))
sailor_id <- as.character(sailor_node$id)

# --- Prepare edges for igraph and visNetwork ---
edges_df_processed <- edges_tbl %>%
  select(source, target, `Edge Type`, key) %>%
  mutate(across(c(source, target), as.character)) %>%
  filter(source %in% nodes_tbl_cleaned$id & target %in% nodes_tbl_cleaned$id) %>%
  rename(from = source, to = target)

# --- Core Logic for the New Visualization ---

# 1. Filter edges to only include the desired interaction types
relevant_edges_for_group_interactions <- edges_df_processed %>%
  filter(`Edge Type` %in% desired_edge_types_for_group_interactions)

# 2. Identify all nodes (including Sailor Shift) connected by these specific edge types
nodes_connected_by_specific_edges <- unique(c(relevant_edges_for_group_interactions$from, relevant_edges_for_group_interactions$to))

# 3. Filter for 'MusicalGroup' and 'Person' nodes that are within this specific interaction context,
#    AND explicitly include 'Sailor Shift' node.
target_group_node_ids <- nodes_tbl_cleaned %>%
  filter(id %in% nodes_connected_by_specific_edges) %>%
  filter(`Node Type` %in% c("MusicalGroup", "Person")) %>%
  pull(id)

# Add sailor_id to the list of target group nodes
target_group_node_ids <- unique(c(target_group_node_ids, sailor_id))


# 4. Prepare the final nodes for the visualization
nodes_for_new_vis <- nodes_tbl_cleaned %>%
  filter(id %in% target_group_node_ids) %>%
  rowwise() %>% # Process mutations row by row
  mutate(
    id = as.character(id),
    label = name,
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      get_html_detail(stage_name, "Stage Name"),
      get_html_detail(release_date, "Release Date"),
      get_html_detail(genre, "Genre"),
      get_html_detail(notable, "Notable")
    ),
    group = `Node Type`, # Group by Node Type for coloring/legend
    size = ifelse(id == sailor_id, 40, 20), # Make Sailor Shift node larger
    color = recode(`Node Type`, !!!all_node_type_colors, .default = all_node_type_colors["Unknown"]),
    color = ifelse(id == sailor_id, "gold", color) # Override for Sailor Shift
  ) %>%
  ungroup() # Revert to normal data frame operations after rowwise

# --- DEBUG: Check final node groups and colors ---
cat("\n--- Nodes for Visualization and Their Assigned Colors ---\n")
print(nodes_for_new_vis %>% distinct(group, color) %>% arrange(group))
cat("--- End Debug Info ---\n\n")


# 5. Prepare the final edges for the visualization
edges_for_new_vis <- relevant_edges_for_group_interactions %>%
  filter(from %in% nodes_for_new_vis$id & to %in% nodes_for_new_vis$id) %>%
  mutate(
    label = `Edge Type`,
    title = `Edge Type`,
    arrows = "to",
    color = recode(`Edge Type`, !!!all_edge_type_colors, .default = all_edge_type_colors["default"])
  )

# --- IMPORTANT: Check if nodes or edges are empty before plotting ---
if (nrow(nodes_for_new_vis) == 0) {
  message("No nodes found for the specified filters. Cannot create the network graph.")
} else if (nrow(edges_for_new_vis) == 0) {
  message("No edges found for the specified filters between the selected nodes. The network graph will be empty or show only isolated nodes.")
} else {
  # --- Create the NEW visNetwork plot ---
  graph_group_interactions <- visNetwork(nodes = nodes_for_new_vis, edges = edges_for_new_vis,
                                         main = paste0("Interactions of '", target_name, "' with Musical Groups and Persons")) %>%
    visNodes(
      color = list(
        background = ~color,
        border = "black",
        highlight = list(background = "red", border = "darkred"),
        hover = list(background = "lightgray", border = "darkgray")
      ),
      shadow = TRUE,
      font = list(size = 12),
      shape = "dot"
    ) %>%
    visEdges(
      color = list(color = ~color, highlight = ~color),
      smooth = TRUE,
      shadow = TRUE,
      font = list(size = 10, align = "middle")
    ) %>%
    visOptions(
      highlightNearest = TRUE,
      nodesIdSelection = list(enabled = TRUE, selected = sailor_id),
      selectedBy = "group"
    )

  # Dynamic visGroups based on actual groups present in nodes_for_new_vis
  # This ensures the legend only shows relevant groups with their correct mapped colors
  unique_groups_in_vis <- nodes_for_new_vis %>%
    distinct(group) %>%
    pull(group)

  if (length(unique_groups_in_vis) > 0) {
    for (g_name in unique_groups_in_vis) {
      # Use the color defined in all_node_type_colors for the legend entry
      # Fallback to "Unknown" color if a group is somehow not in the map
      legend_color <- all_node_type_colors[g_name]
      if (is.na(legend_color)) legend_color <- all_node_type_colors["Unknown"]

      graph_group_interactions <- graph_group_interactions %>%
        visGroups(groupname = g_name, color = legend_color, shape = "dot")
    }
  }


  # Separate legend for nodes (on the left)
  graph_group_interactions <- graph_group_interactions %>%
    visLegend(
      main = "Node Types",
      useGroups = FALSE,
      position = "left",
      width = 0.15
    ) %>%
    # Separate legend for edges (on the right)
    visLegend(
      main = "Edge Types",
      addEdges = data.frame(
        color = all_edge_type_colors[desired_edge_types_for_group_interactions],
        label = desired_edge_types_for_group_interactions,
        font.align = "top"
      ),
      position = "right",
      width = 0.15
    ) %>%
    visInteraction(
      navigationButtons = TRUE,
      keyboard = TRUE
    ) %>%
    visIgraphLayout(layout = "layout_with_fr", randomSeed = 42)

  # Save the network as an HTML file
  visSave(graph_group_interactions, file = paste0(target_name, "_group_interactions_with_sailor_shift_highlighted.html"))

  # Display the network
  graph_group_interactions
}
```

## 2 hop graph limiting the edges

next progrssion to limiting the edges and filter for those linked to sailor shift. However from the graph, we can see that there are songs with relationships as well. and missing linkages to the person or musical group that are linked to sailor shift - more edges need to be included

```{r}
# library(dplyr)
# library(jsonlite)
# library(igraph)
# library(visNetwork)
# library(viridisLite) # For the viridis color palette, used for group_colors
# 
# # --- 1. Load your JSON data ---
# # Assuming 'MC1_graph.json' is in your working directory
# kg <- fromJSON("data/MC1_graph.json")
# nodes_tbl <- as_tibble(kg$nodes)
# edges_tbl <- as_tibble(kg$links)
# 
# # --- Configuration ---
# target_name <- "Sailor Shift"
max_hops_for_context <- 2 # Define the maximum number of hops from Sailor Shift

# --- Define the specific edge types for this new visualization ---
desired_edge_types_for_group_interactions <- c(
  "InterpolatesFrom",
  "DirectlySamples",
  "InStyleOf",
  "CoverOf"
)


# --- IMPORTANT: Strict Node ID Cleaning ---
nodes_tbl_cleaned <- nodes_tbl %>%
  mutate(
    temp_numeric_id = as.numeric(as.character(id))
  ) %>%
  filter(!is.na(temp_numeric_id)) %>%
  mutate(id = as.character(temp_numeric_id)) %>%
  select(-temp_numeric_id)

# --- Get target node ID ---
sailor_node <- nodes_tbl_cleaned %>% filter(name == target_name)
if (nrow(sailor_node) == 0) stop(paste("No node named '", target_name, "' found in cleaned data.", sep=""))
sailor_id <- as.character(sailor_node$id)

# --- Prepare edges for igraph and visNetwork ---
edges_df_processed <- edges_tbl %>%
  select(source, target, `Edge Type`, key) %>%
  filter(source %in% nodes_tbl_cleaned$id & target %in% nodes_tbl_cleaned$id) %>%
  mutate(across(c(source, target), as.character)) %>%
  rename(from = source, to = target)

# --- Build igraph from full edges_df_processed for neighborhood calculation ---
g <- graph_from_data_frame(edges_df_processed, directed = FALSE) # Use directed = TRUE if your graph is truly directed for path finding

# --- Core Logic for the New Visualization with Hop Limit ---

# 1. Get nodes within N-hop neighborhood of Sailor Shift
ego_nodes_indices <- ego(graph = g, order = max_hops_for_context, nodes = sailor_id, mode = "all")[[1]]
connected_ids_within_hops <- names(ego_nodes_indices)

# 2. Filter edges to be within this N-hop neighborhood AND also be one of the desired interaction types
relevant_edges_for_display <- edges_df_processed %>%
  filter(from %in% connected_ids_within_hops & to %in% connected_ids_within_hops) %>% # Filter by hops first
  filter(`Edge Type` %in% desired_edge_types_for_group_interactions) # Then by specific edge types

# 3. Identify all nodes involved in these filtered edges
nodes_involved_in_filtered_edges <- unique(c(relevant_edges_for_display$from, relevant_edges_for_display$to))

# 4. Filter for ALL desired node types from the nodes involved in the filtered edges,
#    AND explicitly include 'Sailor Shift' node.
target_nodes_for_vis <- nodes_tbl_cleaned %>%
  filter(id %in% nodes_involved_in_filtered_edges) %>%
  filter(`Node Type` %in% c("Person", "Song", "RecordLabel", "Album", "MusicalGroup")) %>%
  pull(id)

# Add sailor_id to the list of target nodes for visualization
target_nodes_for_vis <- unique(c(target_nodes_for_vis, sailor_id))


# 5. Prepare the final nodes for the visualization
nodes_for_new_vis <- nodes_tbl_cleaned %>%
  filter(id %in% target_nodes_for_vis) %>%
  mutate(
    id = as.character(id),
    label = name,
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      if_else(!is.na(stage_name), paste0("<b>Stage Name:</b> ", stage_name, "<br>"), ""),
      if_else(!is.na(release_date), paste0("<b>Release Date:</b> ", release_date, "<br>"), ""),
      if_else(!is.na(genre), paste0("<b>Genre:</b> ", genre, "<br>"), ""),
      if_else(!is.na(notable), paste0("<b>Notable:</b> ", notable, "<br>"), "")
    ),
    group = `Node Type`,
    size = ifelse(id == sailor_id, 30, 20),
    base_color = all_node_type_colors[`Node Type`],
    base_color = ifelse(is.na(base_color), all_node_type_colors["default"], base_color),
    color = ifelse(id == sailor_id, "gold", base_color)
  ) %>%
  select(-base_color)

# For any node types not explicitly defined in all_node_type_colors, use the default
nodes_for_new_vis$color[is.na(nodes_for_new_vis$color)] <- all_node_type_colors["default"]


# 6. Prepare the final edges for the visualization
# Filter the 'relevant_edges_for_display' further to ensure both ends are in 'nodes_for_new_vis'
edges_for_new_vis <- relevant_edges_for_display %>%
  filter(from %in% nodes_for_new_vis$id & to %in% nodes_for_new_vis$id) %>%
  mutate(
    label = `Edge Type`,
    title = `Edge Type`,
    arrows = "to",
    color = all_edge_type_colors[`Edge Type`]
  )

# Ensure no NA colors if a type wasn't in `all_edge_type_colors`
edges_for_new_vis$color[is.na(edges_for_new_vis$color)] <- all_edge_type_colors["default"]

# --- IMPORTANT: Check if nodes or edges are empty before plotting ---
if (nrow(nodes_for_new_vis) == 0) {
  message("No nodes found for the specified filters and hop limit. Cannot create the network graph.")
} else if (nrow(edges_for_new_vis) == 0) {
  message("No edges found for the specified filters and hop limit between the selected nodes. The network graph will be empty or show only isolated nodes.")
} else {
  # --- Create the NEW visNetwork plot ---
  graph_group_interactions <- visNetwork(nodes = nodes_for_new_vis, edges = edges_for_new_vis,
                                         main = paste0("Interactions of '", target_name, "' (", max_hops_for_context, "-hop relevant connections)")) %>% # Updated title
    visNodes(
      color = list(
        background = ~color,
        border = "black",
        highlight = list(background = "red", border = "darkred"),
        hover = list(background = "lightgray", border = "darkgray")
      ),
      shadow = TRUE,
      font = list(size = 12),
      shape = "dot"
    ) %>%
    visEdges(
      color = list(color = ~color, highlight = ~color),
      smooth = TRUE,
      shadow = TRUE,
      font = list(size = 10, align = "middle")
    ) %>%
    visOptions(
      highlightNearest = TRUE,
      nodesIdSelection = list(enabled = TRUE, selected = sailor_id),
      selectedBy = "group"
    ) %>%
    # Define node groups and their colors explicitly for the legend using global map
    visGroups(groupname = "Person", color = all_node_type_colors["Person"]) %>%
    visGroups(groupname = "MusicalGroup", color = all_node_type_colors["MusicalGroup"]) %>%
    visGroups(groupname = "Song", color = all_node_type_colors["Song"]) %>%
    visGroups(groupname = "RecordLabel", color = all_node_type_colors["RecordLabel"]) %>%
    visGroups(groupname = "Album", color = all_node_type_colors["Album"]) %>%

    # Separate legend for nodes (on the left)
    visLegend(
      main = "Node Types",
      useGroups = TRUE,
      position = "left",
      width = 0.15
    ) %>%
    # Separate legend for edges (on the right)
    # visLegend(
    #   main = "Edge Types",
    #   addEdges = data.frame(
    #     color = all_edge_type_colors[desired_edge_types_for_group_interactions],
    #     label = desired_edge_types_for_group_interactions,
    #     font.align = "top"
    #   ),
    #   position = "right",
    #   width = 0.15
    # ) %>%
    visInteraction(
      navigationButtons = TRUE,
      keyboard = TRUE
    ) %>%
    visIgraphLayout(layout = "layout_with_fr", randomSeed = 42)
      }

#   # Save the network as an HTML file
#   visSave(graph_group_interactions, file = paste0(target_name, "_interactions_", max_hops_for_context, "hop_related_types_highlighted.html")) # Updated filename

  # Display the network
  graph_group_interactions

```

## Final version aggregated combined:

This graph will plot all the edges connected directly or indirectly from sailor shift to another person

```{r}
# Libraries
library(dplyr)
library(jsonlite)
library(igraph)
library(visNetwork)
library(viridisLite)
library(stringr)

# --- 1. Load your JSON data ---
kg <- fromJSON("data/MC1_graph.json")
nodes_tbl <- as_tibble(kg$nodes)
edges_tbl <- as_tibble(kg$links)

# --- Configuration ---
target_name <- "Sailor Shift"
max_hops_for_context <- 2 # Maximum number of hops for the subgraph
graph_title <- paste0("'", target_name, "' Network (2-hop Context with Inferred Artiste Genres & Aggregated Edge Types)")

# --- Define Global Colors for Node Types ---
# all_node_type_colors <- c(
#   "Song" = "lightblue",
#   "Person" = "orange",
#   "MusicalGroup" = "purple",
#   "RecordLabel" = "lightgreen",
#   "Album" = "brown",
#   "default" = "gray" # Fallback for any unmapped Node Types
# )
# 
# # --- Define Global Colors for Edge Types ---
# all_edge_type_colors <- c(
#   "PerformerOf" = "#FF5733", "ComposerOf" = "#33FF57", "ProducerOf" = "#3357FF",
#   "LyricistOf" = "#FF33F5", "RecordedBy" = "#F5FF33", "InterpolatesFrom" = "#8A2BE2",
#   "InStyleOf" = "#DAA520", "LyricalReferenceTo" = "#5F9EA0", "CoverOf" = "#DC143C",
#   "DirectlySamples" = "#6A5ACD", "DistributedBy" = "#20B2AA", "MemberOf" = "#8B4513",
#   "default" = "#CCCCCC" # Fallback for unlisted edge types
# )

# --- Define which edge types to display and include in the legend (for aggregation) ---
desired_edge_types_to_display <- c(
  "InterpolatesFrom",
  "DirectlySamples",
  "InStyleOf",
  "CoverOf",
  "LyricalReferenceTo",
  "ProducerOf",
  "ComposerOf",
  "PerformerOf",
  "LyricistOf",
  "MemberOf"
)

# --- Strict Node ID Cleaning ---
nodes_tbl_cleaned <- nodes_tbl %>%
  mutate(id = as.character(id)) %>% # Convert original ID to character first
  mutate(id = trimws(id)) %>%       # Trim whitespace from character IDs
  mutate(temp_numeric_id = suppressWarnings(as.numeric(id))) %>% # suppressWarnings to avoid warnings for NAs
  filter(!is.na(temp_numeric_id)) %>% # Keep only IDs that successfully converted to numeric
  mutate(id = as.character(temp_numeric_id)) %>% # Convert numeric back to character for consistent IDs
  select(-temp_numeric_id) %>% # Remove the temporary column
  distinct(id, .keep_all = TRUE) %>% # Ensure unique IDs based on the cleaned ID
  mutate(`Node Type` = trimws(`Node Type`)) # Clean Node Type strings

# --- Get target node ID from the cleaned nodes table ---
sailor_node <- nodes_tbl_cleaned %>% filter(name == trimws(target_name))
if (nrow(sailor_node) == 0) stop(paste("No node named '", target_name, "' found in cleaned data.", sep=""))
sailor_id <- as.character(sailor_node$id)

# --- Prepare edges for igraph (using original IDs) ---
valid_original_node_ids <- nodes_tbl_cleaned$id

edges_df_for_igraph <- edges_tbl %>%
  select(source, target, `Edge Type`, key) %>%
  filter(source %in% valid_original_node_ids & target %in% valid_original_node_ids) %>%
  mutate(across(c(source, target), as.character)) %>%
  rename(from = source, to = target)

# --- DIAGNOSTIC CHECK: Ensure no duplicate vertex IDs before building igraph ---
if (any(duplicated(nodes_tbl_cleaned$id))) {
  duplicate_ids <- nodes_tbl_cleaned$id[duplicated(nodes_tbl_cleaned$id)]
  stop(paste("FATAL ERROR: Duplicate node IDs found in 'nodes_tbl_cleaned$id' even after cleaning. Duplicates: ",
             paste(unique(duplicate_ids), collapse = ", "),
             ". Please inspect your original 'MC1_graph.json' data for these IDs.", sep=""))
}

# --- Build full igraph with directed = TRUE ---
g_full <- graph_from_data_frame(edges_df_for_igraph, directed = TRUE, vertices = nodes_tbl_cleaned$id)

# --- Get 2-hop ego network around Sailor Shift ---
ego_nodes_indices_overall <- ego(graph = g_full, order = max_hops_for_context, nodes = sailor_id, mode = "all")[[1]]
connected_ids_ego <- names(ego_nodes_indices_overall)

# --- Step 1: Get all songs linked to Sailor Shift ---
sailor_connected_songs <- edges_df_for_igraph %>%
  filter((from == sailor_id | to == sailor_id) & `Edge Type` %in% c("PerformerOf", "ComposerOf", "LyricistOf", "ProducerOf")) %>%
  mutate(song_id = ifelse(from == sailor_id, to, from)) %>%
  filter(song_id %in% nodes_tbl_cleaned$id) %>%
  inner_join(nodes_tbl_cleaned %>% select(id, `Node Type`), by = c("song_id" = "id")) %>%
  filter(`Node Type` == "Song") %>%
  pull(song_id)

# --- Step 2: Find all nodes connected to those songs ---
indirect_nodes_via_songs <- edges_df_for_igraph %>%
  filter(from %in% sailor_connected_songs | to %in% sailor_connected_songs) %>%
  mutate(other_id = ifelse(from %in% sailor_connected_songs, to, from)) %>%
  pull(other_id)

# --- Combine all IDs: ego + extra via shared songs ---
connected_ids_overall <- unique(c(sailor_id, connected_ids_ego, indirect_nodes_via_songs))


# --- NEW: Infer Genres for Person/MusicalGroup Nodes ---
genre_inference_edge_types <- c("PerformerOf", "ComposerOf", "ProducerOf", "LyricistOf", "RecordedBy")

artiste_song_genre_links <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% genre_inference_edge_types) %>%
  inner_join(nodes_tbl_cleaned %>% select(id, `Node Type`, genre),
             by = c("to" = "id")) %>%
  filter(`Node Type` == "Song") %>% # Ensure the target node is a Song
  select(artiste_id = from, song_genre = genre) %>%
  filter(!is.na(song_genre) & song_genre != "") # Only consider songs with a defined genre

inferred_genres_for_artistes <- artiste_song_genre_links %>%
  group_by(artiste_id) %>%
  summarise(
    inferred_genre = paste(sort(unique(song_genre)), collapse = ", "),
    .groups = 'drop'
  )

# --- Helper function for safely adding details to node title ---
get_html_detail <- function(data_row, col_name, display_label) {
  if (col_name %in% names(data_row) && !is.na(data_row[[col_name]]) && data_row[[col_name]] != "") { # Added check for empty string
    return(paste0("<b>", display_label, ":</b> ", data_row[[col_name]], "<br>"))
  } else {
    return("")
  }
}

# --- Prepare the final nodes for the visualization (Coloring by Node Type) ---
nodes_for_combined_vis <- nodes_tbl_cleaned %>%
  filter(id %in% connected_ids_overall) %>%
  # Left join inferred genres to Person/MusicalGroup nodes
  left_join(inferred_genres_for_artistes, by = c("id" = "artiste_id")) %>%
  rowwise() %>% # Process row by row for dynamic title generation
  mutate(
    id = as.character(id),
    label = name,
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      get_html_detail(cur_data(), "stage_name", "Stage Name"),
      get_html_detail(cur_data(), "release_date", "Release Date"),
      get_html_detail(cur_data(), "genre", "Genre (Node)"), # Original node genre if exists
      get_html_detail(cur_data(), "inferred_genre", "Genre (Inferred)"), # New inferred genre
      get_html_detail(cur_data(), "notable", "Notable")
    ),
    # Group nodes explicitly by Node Type for filtering and consistent coloring
    group = `Node Type`,
    size = ifelse(id == sailor_id, 50, 15), # Sailor Shift node larger
    # Determine node color based on 'Node Type' and Sailor Shift override
    base_color = all_node_type_colors[`Node Type`],
    node_display_color = ifelse(is.na(base_color), all_node_type_colors["default"], base_color),
    node_display_color = ifelse(id == sailor_id, "gold", node_display_color) # Sailor Shift is gold
  ) %>%
  ungroup() %>%
  select(-base_color)


# --- Prepare Edges for visNetwork (AGGREGATED) ---
sub_edges_combined <- edges_df_for_igraph %>%
  filter(from %in% nodes_for_combined_vis$id & to %in% nodes_for_combined_vis$id) %>%
  filter(`Edge Type` %in% desired_edge_types_to_display) %>%
  # --- AGGREGATE EDGES HERE ---
  group_by(from, to) %>%
  summarise(
    aggregated_label = paste(sort(unique(`Edge Type`)), collapse = ", "),
    color = all_edge_type_colors[first(`Edge Type`)], # Color based on the first edge type
    arrows = "to",
    .groups = 'drop'
  ) %>%
  mutate(
    label = aggregated_label, # Use the combined label for display
    title = aggregated_label # Use the combined label for hover tooltip
  ) %>%
  # Ensure no NA colors if a type wasn't in `all_edge_type_colors`
  mutate(color = ifelse(is.na(color), all_edge_type_colors["default"], color))


# --- Prepare groups for visGroups (robust legend) ---
actual_node_groups_combined <- unique(nodes_for_combined_vis$group)
actual_node_groups_combined <- actual_node_groups_combined[!is.na(actual_node_groups_combined) & actual_node_groups_combined != ""]

if (length(actual_node_groups_combined) == 0) {
  message("Warning: No valid node groups found for visGroups. Legend might not display correctly.")
  groups_for_visnetwork_combined <- data.frame(id = character(0), color = character(0), label = character(0), stringsAsFactors = FALSE)
} else {
  groups_for_visnetwork_combined <- data.frame(
    id = actual_node_groups_combined,
    color = as.character(sapply(actual_node_groups_combined, function(g) {
      if (!is.na(all_node_type_colors[g])) {
        return(all_node_type_colors[g])
      } else {
        return(all_node_type_colors["default"])
      }
    })),
    label = actual_node_groups_combined,
    stringsAsFactors = FALSE
  )
}


# --- IMPORTANT: Check if nodes or edges are empty before plotting ---
if (nrow(nodes_for_combined_vis) == 0) {
  message("No nodes found for the specified filters. Cannot create the network graph.")
} else if (nrow(sub_edges_combined) == 0) {
  message("No edges found for the specified filters between the selected nodes. The network graph will be empty or show only isolated nodes.")
} else {
  # --- Prepare data for the Edge Legend ---
  legend_edge_types_to_display <- names(all_edge_type_colors)[names(all_edge_type_colors) != "default"]

  # --- Create the visNetwork plot ---
  graph_combined_context <- visNetwork(nodes = nodes_for_combined_vis, edges = sub_edges_combined,
                                       main = graph_title) %>%
    visNodes(
      color = list(
        background = ~node_display_color, # Use the calculated display color
        border = "black",
        highlight = list(background = "red", border = "darkred"),
        hover = list(background = "lightgray", border = "darkgray")
      ),
      shadow = TRUE,
      font = list(size = 12),
      shape = "dot"
    ) %>%
    visEdges(
      arrows = "to",
      label = ~label, # Use the aggregated label
      font = list(size = 10, align = "middle"),
      title = ~title, # Use aggregated label for hover
      color = list(color = ~color, highlight = ~color),
      smooth = list(enabled = TRUE, type = "continuous", roundness = 0.5), # Static smoothing
      width = 1
    ) %>%
    visOptions(
      highlightNearest = list(enabled = TRUE, degree = max_hops_for_context, hover = TRUE, algorithm = "hierarchical"), #hierarichal to make it directional restricted
      nodesIdSelection = list(enabled = TRUE, selected = sailor_id, useLabels = TRUE),
      selectedBy = "group" # Now filters by Node Type (Song, Person, Album, etc.)
    ) %>%
    # Apply visGroups for each group found in our prepared data frame
    {
      temp_vis_object <- .
      for (i in 1:nrow(groups_for_visnetwork_combined)) {
        group_id <- groups_for_visnetwork_combined$id[i]
        group_color <- groups_for_visnetwork_combined$color[i]
        temp_vis_object <- temp_vis_object %>%
          visGroups(groupname = group_id, color = group_color)
      }
      temp_vis_object
    } %>% # End of the curly braces block
    visLegend(
      main = "Node Types", # Now clearly states "Node Types"
      useGroups = TRUE,
      position = "left",
      width = 0.15
    ) %>%
    # --- Edge Legend: Show original edge types, not aggregated labels ---
    visLegend(
      main = "Edge Types",
      addEdges = data.frame(
        color = all_edge_type_colors[legend_edge_types_to_display],
        label = legend_edge_types_to_display,
        font.align = "top"
      ),
      position = "left",
      width = 0.15
    ) %>%
    visInteraction(
      navigationButtons = TRUE,
      keyboard = TRUE
    ) %>%
    # Apply initial igraph layout (static)
    visIgraphLayout(layout = "layout_with_fr", randomSeed = 1234) %>%
    # Explicitly disable physics to make the graph static
    visPhysics(enabled = FALSE)

  # Display the network
  graph_combined_context

  # Optional: Save the network as an HTML file
  # visSave(graph_combined_context, file = paste0(target_name, "_combined_nodetype_colors_", max_hops_for_context, "hop.html"))
}
```

To make it cleaner, removed the songs linked to the person or musical group. split into 2 graphs. outward and inward

seperate code inside for a legend addition

## Outward final graph final with star shape

```{r}
# --- Load Libraries ---
library(dplyr)
library(jsonlite)
library(visNetwork)
library(stringr)
library(lubridate)
library(RColorBrewer)
library(tidyr)

# --- Global Definitions ---
desired_edge_types_to_display <- c(
  "PerformerOf", "ComposerOf", "ProducerOf", "LyricistOf", "RecordedBy",
  "InterpolatesFrom", "InStyleOf", "LyricalReferenceTo", "CoverOf",
  "DirectlySamples", "DistributedBy", "MemberOf"
)

# all_node_type_colors <- c(
#   "Song" = "lightblue",
#   "Album" = "brown",
#   "Person" = "orange",
#   "MusicalGroup" = "purple",
#   "RecordLabel" = "lightgreen",
#   "Unknown" = "gray"
# )
# 
# all_edge_type_colors <- c(
#   "PerformerOf" = "#FF5733", "ComposerOf" = "#33FF57", "ProducerOf" = "#3357FF",
#   "LyricistOf" = "#FF33F5", "RecordedBy" = "#F5FF33", "InterpolatesFrom" = "#8A2BE2",
#   "InStyleOf" = "#DAA520", "LyricalReferenceTo" = "#5F9EA0", "CoverOf" = "#DC143C",
#   "DirectlySamples" = "#6A5ACD", "DistributedBy" = "#20B2AA", "MemberOf" = "#8B4513",
#   "default" = "#CCCCCC"
# )

get_html_detail <- function(value, label) {
  if (!is.null(value) && !is.na(value) && as.character(value) != "") {
    return(paste0("<b>", label, ":</b> ", as.character(value), "<br>"))
  }
  return("")
}

# --- Simulate missing data/variables for a runnable example ---
if (!exists("inferred_genres_for_artistes")) {
  inferred_genres_for_artistes <- tibble(
    artiste_id = character(),
    inferred_genre = character()
  )
}

if (!exists("groups_for_visnetwork_combined")) {
  groups_for_visnetwork_combined <- tibble(
    id = names(all_node_type_colors),
    color = all_node_type_colors
  )
}
if (!exists("legend_edge_types_to_display")) {
  legend_edge_types_to_display <- desired_edge_types_to_display[desired_edge_types_to_display %in% names(all_edge_type_colors)]
}

# --- Load and Clean Data ---
tryCatch({
  kg <- fromJSON("data/MC1_graph.json")
  nodes_tbl_raw <- as_tibble(kg$nodes)
  edges_tbl_raw <- as_tibble(kg$links)
}, error = function(e) {
  stop("Error: 'data/MC1_graph.json' not found or could not be read. Please ensure the file is in the correct path.\n", e$message)
})

# --- Improved release_date parsing and year extraction ---
nodes_tbl_cleaned <- nodes_tbl_raw %>%
  mutate(id = as.character(id)) %>%
  mutate(id = trimws(id)) %>%
  mutate(id = tolower(id)) %>%
  distinct(id, .keep_all = TRUE) %>%
  mutate(
    release_date_parsed = suppressWarnings(parse_date_time(release_date, orders = c("ymd", "Ymd", "Y-m-d", "Y/m/d", "Y"))),
    release_year = ifelse(
      !is.na(release_date_parsed),
      year(release_date_parsed),
      suppressWarnings(as.integer(str_extract(as.character(release_date), "\\d{4}")))
    )
  )

if ("Node Type" %in% names(nodes_tbl_cleaned)) {
  nodes_tbl_cleaned <- nodes_tbl_cleaned %>%
    mutate(`Node Type` = trimws(`Node Type`))
} else {
  warning("Column 'Node Type' not found in nodes_tbl_cleaned. Node typing might be affected.")
  nodes_tbl_cleaned <- nodes_tbl_cleaned %>% mutate(`Node Type` = "Unknown")
}

if (!"notoriety_date" %in% names(nodes_tbl_cleaned) || all(is.na(nodes_tbl_cleaned$notoriety_date))) {
  set.seed(456)
  nodes_tbl_cleaned <- nodes_tbl_cleaned %>%
    mutate(
      temp_release_date = ymd(release_date, quiet = TRUE),
      notoriety_date = if_else(
        !is.na(temp_release_date) & sample(c(TRUE, FALSE), n(), replace = TRUE, prob = c(0.15, 0.85)),
        temp_release_date + days(sample(30:365, n(), replace = TRUE)),
        as.Date(NA)
      ),
      notoriety_year = year(notoriety_date)
    ) %>%
    select(-temp_release_date)
} else {
  nodes_tbl_cleaned <- nodes_tbl_cleaned %>%
    mutate(notoriety_year = suppressWarnings(as.integer(str_extract(as.character(notoriety_date), "\\d{4}"))))
}

if (!"notable" %in% names(nodes_tbl_cleaned)) {
  set.seed(123)
  nodes_tbl_cleaned <- nodes_tbl_cleaned %>%
    mutate(notable = sample(c(TRUE, FALSE), n(), replace = TRUE, prob = c(0.2, 0.8)))
}

if (!"stage_name" %in% names(nodes_tbl_cleaned)) {
  nodes_tbl_cleaned$stage_name <- NA_character_
}
if (!"genre" %in% names(nodes_tbl_cleaned)) {
  nodes_tbl_cleaned$genre <- NA_character_
}

# --- Identify Sailor Shift Node ---
target_name <- "Sailor Shift"
sailor_node <- nodes_tbl_cleaned %>% filter(tolower(name) == tolower(target_name))
if (nrow(sailor_node) == 0) stop(paste("No node named '", target_name, "' found.", sep=""))
sailor_id <- sailor_node$id

# --- Prepare Edges for visNetwork (and ensure IDs are consistent) ---
edges_df_for_igraph <- edges_tbl_raw %>%
  rename(from = source, to = target) %>%
  mutate(across(c(from, to), as.character)) %>%
  mutate(across(c(from, to), trimws)) %>%
  mutate(across(c(from, to), tolower))

valid_node_ids_set <- unique(nodes_tbl_cleaned$id)
edges_df_for_igraph <- edges_df_for_igraph %>%
  filter(from %in% valid_node_ids_set & to %in% valid_node_ids_set)

# --- Outward Graph Logic ---
sailor_songs <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% desired_edge_types_to_display,
         from == sailor_id | to == sailor_id) %>%
  mutate(target_id = ifelse(from == sailor_id, to, from)) %>%
  inner_join(nodes_tbl_cleaned, by = c("target_id" = "id")) %>%
  filter(`Node Type` == "Song") %>%
  pull(target_id)

sailor_albums <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% desired_edge_types_to_display,
         from == sailor_id | to == sailor_id) %>%
  mutate(target_id = ifelse(from == sailor_id, to, from)) %>%
  inner_join(nodes_tbl_cleaned, by = c("target_id" = "id")) %>%
  filter(`Node Type` == "Album") %>%
  pull(target_id)

linked_out_targets <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% desired_edge_types_to_display,
         from %in% union(sailor_songs, sailor_albums)) %>%
  pull(to)

all_out_targets <- union(union(sailor_songs, sailor_albums), linked_out_targets)

contributors_to_targets <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% desired_edge_types_to_display,
         to %in% all_out_targets)

edges_from_sailor <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% desired_edge_types_to_display,
         from == sailor_id | from %in% union(sailor_songs, sailor_albums))

# --- 7. Final edge list ---
edges_outward_filtered <- bind_rows(edges_from_sailor, contributors_to_targets) %>%
  distinct(from, to, `Edge Type`, key)

# --- 7b. Add MemberOf links for existing Person nodes to their MusicalGroups ---
# Use IDs already present in the network after step 7
outward_ids <- unique(c(edges_outward_filtered$from, edges_outward_filtered$to, sailor_id))

memberof_links <- edges_df_for_igraph %>%
  filter(`Edge Type` == "MemberOf") %>%
  filter(from %in% outward_ids)

edges_outward_filtered <- bind_rows(edges_outward_filtered, memberof_links) %>%
  distinct(from, to, `Edge Type`, key)

# Update outward_ids again with newly introduced MusicalGroups
outward_ids <- unique(c(edges_outward_filtered$from, edges_outward_filtered$to, sailor_id))




# --- Node Coloring Logic ---
min_release_year_for_gradient <- nodes_tbl_cleaned %>%
  filter(`Node Type` %in% c("Song", "Album") & id %in% outward_ids) %>%
  pull(release_year) %>%
  min(na.rm = TRUE)

max_release_year_for_gradient <- nodes_tbl_cleaned %>%
  filter(`Node Type` %in% c("Song", "Album") & id %in% outward_ids) %>%
  pull(release_year) %>%
  max(na.rm = TRUE)

color_palette_func <- colorRampPalette(rev(brewer.pal(9, "Blues"))) # Darker = larger year

song_palette_func <- colorRampPalette(brewer.pal(9, "YlOrRd"))   # Songs: yellow to red
album_palette_func <- colorRampPalette(brewer.pal(9, "PuBuGn"))  # Albums: purple to green/blue

min_song_year <- nodes_tbl_cleaned %>%
  filter(`Node Type` == "Song" & id %in% outward_ids) %>%
  pull(release_year) %>%
  min(na.rm = TRUE)

max_song_year <- nodes_tbl_cleaned %>%
  filter(`Node Type` == "Song" & id %in% outward_ids) %>%
  pull(release_year) %>%
  max(na.rm = TRUE)

min_album_year <- nodes_tbl_cleaned %>%
  filter(`Node Type` == "Album" & id %in% outward_ids) %>%
  pull(release_year) %>%
  min(na.rm = TRUE)

max_album_year <- nodes_tbl_cleaned %>%
  filter(`Node Type` == "Album" & id %in% outward_ids) %>%
  pull(release_year) %>%
  max(na.rm = TRUE)

nodes_outward_vis <- nodes_tbl_cleaned %>%
  filter(id %in% outward_ids) %>%
  left_join(inferred_genres_for_artistes, by = c("id" = "artiste_id")) %>%
  rowwise() %>%
  mutate(
    label = name,
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      get_html_detail(stage_name, "Stage Name"),
      get_html_detail(release_date, "Release Date"),
      get_html_detail(genre, "Genre (Node)"),
      get_html_detail(inferred_genre, "Genre (Inferred)"),
      get_html_detail(notable, "Notable")
    ),
    group = `Node Type`,
    size = case_when(
      id == sailor_id ~ 60,
      TRUE ~ 15
    ),
    shape = case_when(
      (`Node Type` %in% c("Song", "Album")) & notable ~ "star",
      TRUE ~ "dot"
    ),
    color.background = case_when(
      id == sailor_id ~ "gold",
      `Node Type` == "Song" & !is.na(release_year) ~ {
        if (min_song_year == max_song_year) {
          song_palette_func(1)[1]
        } else {
          scaled_year <- (release_year - min_song_year) / (max_song_year - min_song_year)
          scaled_year <- pmax(0, pmin(1, scaled_year))
          song_palette_func(100)[round(scaled_year * 99) + 1]
        }
      },
      `Node Type` == "Album" & !is.na(release_year) ~ {
        if (min_album_year == max_album_year) {
          album_palette_func(1)[1]
        } else {
          scaled_year <- (release_year - min_album_year) / (max_album_year - min_album_year)
          scaled_year <- pmax(0, pmin(1, scaled_year))
          album_palette_func(100)[round(scaled_year * 99) + 1]
        }
      },
      TRUE ~ unname(all_node_type_colors[as.character(`Node Type`)])
    ),
    color.background = ifelse(is.na(color.background), all_node_type_colors["Unknown"], color.background),
    color.border = "black",
    color.highlight.background = "red",
    color.highlight.border = "darkred",
    color.hover.background = "lightgray",
    color.hover.border = "darkgray"
  ) %>%
  ungroup()

edges_outward_final <- edges_outward_filtered %>%
  filter(from %in% nodes_outward_vis$id & to %in% nodes_outward_vis$id) %>%
  group_by(from, to) %>%
  summarise(
    aggregated_label = paste(sort(unique(`Edge Type`)), collapse = ", "),
    color = all_edge_type_colors[first(`Edge Type`)],
    arrows = "to",
    .groups = 'drop'
  ) %>%
  mutate(
    label = aggregated_label,
    title = aggregated_label,
    color = ifelse(is.na(color), all_edge_type_colors["default"], color)
  )

# --- Calculate degree for each node in the subgraph (without igraph) ---
degree_df <- edges_outward_final %>%
  select(from, to) %>%
  pivot_longer(cols = c(from, to), values_to = "id") %>%
  count(id, name = "degree")

# Optionally rescale for better visualization (e.g., between 15 and 60)
rescale <- function(x, to = c(15, 150)) {
  rng <- range(x, na.rm = TRUE)
  if (diff(rng) == 0) return(rep(mean(to), length(x)))
  (x - rng[1]) / diff(rng) * diff(to) + to[1]
}
degree_df$degree_scaled <- rescale(degree_df$degree)

# Join degree to nodes_outward_vis and update size
nodes_outward_vis <- nodes_outward_vis %>%
  left_join(degree_df, by = "id") %>%
  mutate(size = ifelse(id == sailor_id, 60, degree_scaled))

# --- Render OUTWARD network ---
graph_outward <- visNetwork(nodes_outward_vis, edges_outward_final,
                            main = paste0("Outward Graph from '", target_name, "' (Nodes by Degree)")) %>%
  visNodes(
    shadow = TRUE,
    font = list(size = 12),
    shape = "dot"
  ) %>%
  visEdges(
    arrows = "to",
    label = ~label,
    font = list(size = 10, align = "middle"),
    title = ~title,
    color = list(color = ~color, highlight = ~color),
    smooth = list(enabled = TRUE, type = "continuous", roundness = 0.5),
    width = 1
  ) %>%
  visOptions(
    highlightNearest = list(enabled = TRUE, degree = 1, hover = TRUE, algorithm = "hierarchical"),
    nodesIdSelection = list(enabled = TRUE, selected = sailor_id, useLabels = TRUE),
    selectedBy = "group"
  ) %>%
  {
    vis_obj <- .
    vis_obj <- vis_obj %>%
      visGroups(groupname = "Song", color = all_node_type_colors["Song"], shape = "dot") %>%
      visGroups(groupname = "Album", color = all_node_type_colors["Album"], shape = "dot") %>%
      visGroups(groupname = "Person", color = all_node_type_colors["Person"], shape = "dot") %>%
      visGroups(groupname = "MusicalGroup", color = all_node_type_colors["MusicalGroup"], shape = "dot") %>%
      visGroups(groupname = "RecordLabel", color = all_node_type_colors["RecordLabel"], shape = "dot") %>%
      visGroups(groupname = "Unknown", color = all_node_type_colors["Unknown"], shape = "dot")
    vis_obj
  } %>%
  visLegend(main = "Node Types", useGroups = TRUE, position = "left", width = 0.15) %>%
  # visLegend(
  #   main = "Edge Types",
  #   addEdges = data.frame(
  #     color = all_edge_type_colors[legend_edge_types_to_display],
  #     label = legend_edge_types_to_display,
  #     font.align = "top"
  #   ),
  #   position = "left",
  #   width = 0.15
  # ) %>%
  visInteraction(navigationButtons = TRUE, keyboard = TRUE) %>%
  visIgraphLayout(layout = "layout_with_fr", randomSeed = 1234) %>%
  visPhysics(enabled = FALSE)


library(htmltools)

# Song gradient legend
song_legend <- tags$div(
  style = "margin-bottom:8px;",
  tags$b("Song Release Year:"),
  tags$div(
    style = sprintf("height:18px;width:200px;background:linear-gradient(to right, %s);border:1px solid #888;margin:2px 0;",
                    paste(song_palette_func(10), collapse = ","))),
  tags$span(min_song_year), 
  tags$span(style="float:right;", max_song_year)
)

# Album gradient legend
album_legend <- tags$div(
  style = "margin-bottom:8px;",
  tags$b("Album Release Year:"),
  tags$div(
    style = sprintf("height:18px;width:200px;background:linear-gradient(to right, %s);border:1px solid #888;margin:2px 0;",
                    paste(album_palette_func(10), collapse = ","))),
  tags$span(min_album_year), 
  tags$span(style="float:right;", max_album_year)
)


graph_outward
library(htmlwidgets)

# Combine legends and network
browsable(
  tagList(
    song_legend,
    album_legend,
    graph_outward
  )
)
```

```         
```

## Inward graph final with star shape

```{r}
# --- Load Libraries ---
library(dplyr)
library(jsonlite)
library(visNetwork)
library(stringr)
library(lubridate)
library(RColorBrewer)
library(tidyr)

# --- Global Definitions ---
desired_edge_types_to_display <- c(
  "PerformerOf", "ComposerOf", "ProducerOf", "LyricistOf", "RecordedBy",
  "InterpolatesFrom", "InStyleOf", "LyricalReferenceTo", "CoverOf",
  "DirectlySamples", "DistributedBy", "MemberOf"
)

# all_node_type_colors <- c(
#   "Song" = "lightblue",
#   "Album" = "brown",
#   "Person" = "deepskyblue",
#   "MusicalGroup" = "purple",
#   "RecordLabel" = "lightgreen",
#   "Unknown" = "gray"
# )
# 
# all_edge_type_colors <- c(
#   "PerformerOf" = "#FF5733", "ComposerOf" = "#33FF57", "ProducerOf" = "#3357FF",
#   "LyricistOf" = "#FF33F5", "RecordedBy" = "#F5FF33", "InterpolatesFrom" = "#8A2BE2",
#   "InStyleOf" = "#DAA520", "LyricalReferenceTo" = "#5F9EA0", "CoverOf" = "#DC143C",
#   "DirectlySamples" = "#6A5ACD", "DistributedBy" = "#20B2AA", "MemberOf" = "#8B4513",
#   "default" = "#CCCCCC"
# )

get_html_detail <- function(row, col, label) {
  value <- row[[col]]
  if (!is.null(value) && !is.na(value) && as.character(value) != "") {
    return(paste0("<b>", label, ":</b> ", as.character(value), "<br>"))
  }
  return("")
}

# --- Simulate missing data/variables for a runnable example ---
if (!exists("inferred_genres_for_artistes")) {
  inferred_genres_for_artistes <- tibble(
    artiste_id = character(),
    inferred_genre = character()
  )
}

if (!exists("groups_for_visnetwork_combined")) {
  groups_for_visnetwork_combined <- tibble(
    id = names(all_node_type_colors),
    color = all_node_type_colors
  )
}
if (!exists("legend_edge_types_to_display")) {
  legend_edge_types_to_display <- desired_edge_types_to_display[desired_edge_types_to_display %in% names(all_edge_type_colors)]
}

# --- Load and Clean Data ---
tryCatch({
  kg <- fromJSON("data/MC1_graph.json")
  nodes_tbl_raw <- as_tibble(kg$nodes)
  edges_tbl_raw <- as_tibble(kg$links)
}, error = function(e) {
  stop("Error: 'data/MC1_graph.json' not found or could not be read. Please ensure the file is in the correct path.\n", e$message)
})

# --- Improved release_date parsing and year extraction ---
nodes_tbl_cleaned <- nodes_tbl_raw %>%
  mutate(id = as.character(id)) %>%
  mutate(id = trimws(id)) %>%
  mutate(id = tolower(id)) %>%
  distinct(id, .keep_all = TRUE) %>%
  mutate(
    release_date_parsed = suppressWarnings(parse_date_time(release_date, orders = c("ymd", "Ymd", "Y-m-d", "Y/m/d", "Y"))),
    release_year = ifelse(
      !is.na(release_date_parsed),
      year(release_date_parsed),
      suppressWarnings(as.integer(str_extract(as.character(release_date), "\\d{4}")))
    )
  )

if ("Node Type" %in% names(nodes_tbl_cleaned)) {
  nodes_tbl_cleaned <- nodes_tbl_cleaned %>%
    mutate(`Node Type` = trimws(`Node Type`))
} else {
  warning("Column 'Node Type' not found in nodes_tbl_cleaned. Node typing might be affected.")
  nodes_tbl_cleaned <- nodes_tbl_cleaned %>% mutate(`Node Type` = "Unknown")
}

if (!"notoriety_date" %in% names(nodes_tbl_cleaned) || all(is.na(nodes_tbl_cleaned$notoriety_date))) {
  set.seed(456)
  nodes_tbl_cleaned <- nodes_tbl_cleaned %>%
    mutate(
      temp_release_date = ymd(release_date, quiet = TRUE),
      notoriety_date = if_else(
        !is.na(temp_release_date) & sample(c(TRUE, FALSE), n(), replace = TRUE, prob = c(0.15, 0.85)),
        temp_release_date + days(sample(30:365, n(), replace = TRUE)),
        as.Date(NA)
      ),
      notoriety_year = year(notoriety_date)
    ) %>%
    select(-temp_release_date)
} else {
  nodes_tbl_cleaned <- nodes_tbl_cleaned %>%
    mutate(notoriety_year = suppressWarnings(as.integer(str_extract(as.character(notoriety_date), "\\d{4}"))))
}

if (!"notable" %in% names(nodes_tbl_cleaned)) {
  set.seed(123)
  nodes_tbl_cleaned <- nodes_tbl_cleaned %>%
    mutate(notable = sample(c(TRUE, FALSE), n(), replace = TRUE, prob = c(0.2, 0.8)))
}

if (!"stage_name" %in% names(nodes_tbl_cleaned)) {
  nodes_tbl_cleaned$stage_name <- NA_character_
}
if (!"genre" %in% names(nodes_tbl_cleaned)) {
  nodes_tbl_cleaned$genre <- NA_character_
}

# --- Identify Sailor Shift Node ---
target_name <- "Sailor Shift"
sailor_node <- nodes_tbl_cleaned %>% filter(tolower(name) == tolower(target_name))
if (nrow(sailor_node) == 0) stop(paste("No node named '", target_name, "' found.", sep=""))
sailor_id <- sailor_node$id

# --- Prepare Edges for visNetwork (and ensure IDs are consistent) ---
edges_df_for_igraph <- edges_tbl_raw %>%
  rename(from = source, to = target) %>%
  mutate(across(c(from, to), as.character)) %>%
  mutate(across(c(from, to), trimws)) %>%
  mutate(across(c(from, to), tolower))

valid_node_ids_set <- unique(nodes_tbl_cleaned$id)
edges_df_for_igraph <- edges_df_for_igraph %>%
  filter(from %in% valid_node_ids_set & to %in% valid_node_ids_set)

# --- 1. Songs linked to Sailor Shift (direct edges) ---
sailor_songs <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% desired_edge_types_to_display,
         from == sailor_id | to == sailor_id) %>%
  mutate(target_id = ifelse(from == sailor_id, to, from)) %>%
  inner_join(nodes_tbl_cleaned, by = c("target_id" = "id")) %>%
  filter(`Node Type` == "Song") %>%
  pull(target_id)

# --- 2. Albums linked to Sailor Shift (direct edges) ---
sailor_albums <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% desired_edge_types_to_display,
         from == sailor_id | to == sailor_id) %>%
  mutate(target_id = ifelse(from == sailor_id, to, from)) %>%
  inner_join(nodes_tbl_cleaned, by = c("target_id" = "id")) %>%
  filter(`Node Type` == "Album") %>%
  pull(target_id)

# --- Songs/albums that link to Sailor Shift's songs or albums ---
linked_in_targets <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% desired_edge_types_to_display,
         to %in% union(sailor_songs, sailor_albums)) %>%
  pull(from)

# --- All songs + albums to include ---
all_in_targets <- union(union(sailor_songs, sailor_albums), linked_in_targets)

# --- Contributors to those songs/albums ---
contributors_to_targets <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% desired_edge_types_to_display,
         to %in% all_in_targets)

# --- Edges to Sailor Shift or her songs/albums ---
edges_to_sailor <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% desired_edge_types_to_display,
         to == sailor_id | to %in% union(sailor_songs, sailor_albums))

# --- Final inward edge set ---
edges_inward_filtered <- bind_rows(edges_to_sailor, contributors_to_targets) %>%
  distinct(from, to, `Edge Type`, key)

# --- Final node set ---
inward_ids <- unique(c(edges_inward_filtered$from, edges_inward_filtered$to, sailor_id))

# --- Gradient palettes for songs and albums ---
song_palette_func <- colorRampPalette(brewer.pal(9, "YlOrRd"))   # Songs: yellow to red
album_palette_func <- colorRampPalette(brewer.pal(9, "PuBuGn"))  # Albums: purple to green/blue

min_song_year <- nodes_tbl_cleaned %>%
  filter(`Node Type` == "Song" & id %in% inward_ids) %>%
  pull(release_year) %>%
  min(na.rm = TRUE)

max_song_year <- nodes_tbl_cleaned %>%
  filter(`Node Type` == "Song" & id %in% inward_ids) %>%
  pull(release_year) %>%
  max(na.rm = TRUE)

min_album_year <- nodes_tbl_cleaned %>%
  filter(`Node Type` == "Album" & id %in% inward_ids) %>%
  pull(release_year) %>%
  min(na.rm = TRUE)

max_album_year <- nodes_tbl_cleaned %>%
  filter(`Node Type` == "Album" & id %in% inward_ids) %>%
  pull(release_year) %>%
  max(na.rm = TRUE)

nodes_inward_vis <- nodes_tbl_cleaned %>%
  filter(id %in% inward_ids) %>%
  left_join(inferred_genres_for_artistes, by = c("id" = "artiste_id")) %>%
  rowwise() %>%
  mutate(
    label = name,
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      get_html_detail(cur_data(), "stage_name", "Stage Name"),
      get_html_detail(cur_data(), "release_date", "Release Date"),
      get_html_detail(cur_data(), "genre", "Genre (Node)"),
      get_html_detail(cur_data(), "inferred_genre", "Genre (Inferred)"),
      get_html_detail(cur_data(), "notable", "Notable")
    ),
    group = `Node Type`,
    size = case_when(
      id == sailor_id ~ 60
      # Other nodes will be set by degree below
    ),
    shape = case_when(
      (`Node Type` %in% c("Song", "Album")) & notable ~ "star",
      TRUE ~ "dot"
    ),
    color.background = case_when(
      id == sailor_id ~ "gold",
      `Node Type` == "Song" & !is.na(release_year) ~ {
        if (min_song_year == max_song_year) {
          song_palette_func(1)[1]
        } else {
          scaled_year <- (release_year - min_song_year) / (max_song_year - min_song_year)
          scaled_year <- pmax(0, pmin(1, scaled_year))
          song_palette_func(100)[round(scaled_year * 99) + 1]
        }
      },
      `Node Type` == "Album" & !is.na(release_year) ~ {
        if (min_album_year == max_album_year) {
          album_palette_func(1)[1]
        } else {
          scaled_year <- (release_year - min_album_year) / (max_album_year - min_album_year)
          scaled_year <- pmax(0, pmin(1, scaled_year))
          album_palette_func(100)[round(scaled_year * 99) + 1]
        }
      },
      TRUE ~ unname(all_node_type_colors[as.character(`Node Type`)])
    ),
    color.background = ifelse(is.na(color.background), all_node_type_colors["Unknown"], color.background),
    color.border = "black",
    color.highlight.background = "red",
    color.highlight.border = "darkred",
    color.hover.background = "lightgray",
    color.hover.border = "darkgray"
  ) %>%
  ungroup()

edges_inward_final <- edges_inward_filtered %>%
  filter(from %in% nodes_inward_vis$id & to %in% nodes_inward_vis$id) %>%
  group_by(from, to) %>%
  summarise(
    aggregated_label = paste(sort(unique(`Edge Type`)), collapse = ", "),
    color = all_edge_type_colors[first(`Edge Type`)],
    arrows = "to",
    .groups = 'drop'
  ) %>%
  mutate(
    label = aggregated_label,
    title = aggregated_label,
    color = ifelse(is.na(color), all_edge_type_colors["default"], color)
  )

# --- Calculate degree for each node in the subgraph (without igraph) ---
degree_df <- edges_inward_final %>%
  select(from, to) %>%
  pivot_longer(cols = c(from, to), values_to = "id") %>%
  count(id, name = "degree")

# Optionally rescale for better visualization (e.g., between 15 and 150)
rescale <- function(x, to = c(15, 150)) {
  rng <- range(x, na.rm = TRUE)
  if (diff(rng) == 0) return(rep(mean(to), length(x)))
  (x - rng[1]) / diff(rng) * diff(to) + to[1]
}
degree_df$degree_scaled <- rescale(degree_df$degree)

# Join degree to nodes_inward_vis and update size
nodes_inward_vis <- nodes_inward_vis %>%
  left_join(degree_df, by = "id") %>%
  mutate(size = ifelse(id == sailor_id, 60, degree_scaled))

# --- Render INWARD network ---
graph_inward <- visNetwork(nodes_inward_vis, edges_inward_final,
                           main = paste0("Inward Graph to '", target_name, "' (Nodes by Degree)")) %>%
  visNodes(
    color = list(
      background = ~color.background,
      border = "black",
      highlight = list(background = "red", border = "darkred"),
      hover = list(background = "lightgray", border = "darkgray")
    ),
    shadow = TRUE,
    font = list(size = 12)
    # Do NOT set size or shape here!
  ) %>%
  visEdges(
    arrows = "to",
    label = ~label,
    font = list(size = 10, align = "middle"),
    title = ~title,
    color = list(color = ~color, highlight = ~color),
    smooth = list(enabled = TRUE, type = "continuous", roundness = 0.5),
    width = 1
  ) %>%
  visOptions(
    highlightNearest = list(enabled = TRUE, degree = 1, hover = TRUE, algorithm = "hierarchical"),
    nodesIdSelection = list(enabled = TRUE, selected = sailor_id, useLabels = TRUE),
    selectedBy = "group"
  ) %>%
  {
    vis_obj <- .
    for (i in 1:nrow(groups_for_visnetwork_combined)) {
      vis_obj <- vis_obj %>%
        visGroups(groupname = groups_for_visnetwork_combined$id[i],
                  color = groups_for_visnetwork_combined$color[i])
    }
    vis_obj
  } %>%
  visLegend(main = "Node Types", useGroups = TRUE, position = "left", width = 0.15) %>%
  # visLegend(
  #   main = "Edge Types",
  #   addEdges = data.frame(
  #     color = all_edge_type_colors[legend_edge_types_to_display],
  #     label = legend_edge_types_to_display,
  #     font.align = "top"
  #   ),
  #   position = "left",
  #   width = 0.15
  # ) %>%
  visInteraction(navigationButtons = TRUE, keyboard = TRUE) %>%
  visIgraphLayout(layout = "layout_with_fr", randomSeed = 1234) %>%
  visPhysics(enabled = FALSE)

graph_inward
library(htmlwidgets)

# Combine legends and network
browsable(
  tagList(
    song_legend,
    album_legend,
    graph_inward  # or graph_outward
  )
)
```

### Sailorshift updated advanced graphs for inward and outward

## Animated Ggraph

# `` {r} # library(dplyr) # library(tidygraph) # library(ggraph) # library(jsonlite) # library(purrr) #  # # --- Load and clean data as before --- # kg <- fromJSON("data/MC1_graph.json") # nodes <- as_tibble(kg$nodes) %>% #   mutate( #     id = as.character(id), #     name = as.character(name), #     `Node Type` = trimws(as.character(`Node Type`)) #   ) %>% #   distinct(id, .keep_all = TRUE) %>% #   rename(node_label = name) %>% #   filter(!is.na(id) & id != "") #  # edges <- as_tibble(kg$links) %>% #   rename(from = source, to = target) %>% #   mutate( #     from = as.character(from), #     to = as.character(to) #   ) %>% #   filter(!is.na(from) & !is.na(to) & from != "" & to != "") %>% #   filter(from %in% nodes$id & to %in% nodes$id) #  # g_ig <- tbl_graph( #   nodes = nodes, #   edges = edges, #   node_key = "id", #   directed = TRUE # ) #  # # --- Find Sailor Shift's ID --- # sailor_id <- nodes %>% filter(trimws(tolower(node_label)) == "sailor shift") %>% pull(id) #  # # --- Identify target nodes (Person or MusicalGroup) --- # target_ids <- nodes %>% #   filter(`Node Type` %in% c("Person", "MusicalGroup"), id != sailor_id) %>% #   pull(id) #  # # --- BFS: Only traverse Song/Album nodes until reaching a Person or MusicalGroup --- # g_igraph <- as.igraph(g_ig) # node_types <- nodes$`Node Type` # names(node_types) <- nodes$id #  # # Function to get all valid paths # find_paths <- function(start_id, target_ids, node_types, g) { #   paths <- list() #   visited <- setNames(rep(FALSE, length(V(g))), V(g)$name) #   queue <- list(list(path = c(start_id))) #   while (length(queue) > 0) { #     current <- queue[[1]] #     queue <- queue[-1] #     last_node <- tail(current$path, 1) #     if (last_node %in% target_ids) { #       paths[[length(paths) + 1]] <- current$path #       next #     } #     # Only continue if not at a Person or MusicalGroup #     if (node_types[last_node] %in% c("Person", "MusicalGroup") && last_node != start_id) next #     neighbors <- neighbors(g, last_node, mode = "out")$name #     for (n in neighbors) { #       if (!n %in% current$path) { # avoid cycles #         queue[[length(queue) + 1]] <- list(path = c(current$path, n)) #       } #     } #   } #   paths # } #  # all_paths <- find_paths(sailor_id, target_ids, node_types, g_igraph) #  # if (length(all_paths) == 0) stop("No valid paths found.") #  # # --- Collect nodes and edges in these paths --- # path_node_ids <- unique(unlist(all_paths)) # path_edges <- unique(do.call(rbind, lapply(all_paths, function(path) { #   if(length(path) < 2) return(NULL) #   data.frame(from = path[-length(path)], to = path[-1], stringsAsFactors = FALSE) # }))) #  # neighbor_ids <- unique(c( #   edges %>% filter(from == sailor_id) %>% pull(to), #   edges %>% filter(to == sailor_id) %>% pull(from) # )) # nodes_sub <- nodes %>% filter(id %in% c(sailor_id, neighbor_ids)) # edges_sub <- edges %>% filter((from == sailor_id & to %in% neighbor_ids) | (to == sailor_id & from %in% neighbor_ids)) # g_sub <- tbl_graph( #   nodes = nodes_sub, #   edges = edges_sub, #   node_key = "id", #   directed = TRUE # ) # ggraph(g_sub, layout = "fr") + #   geom_edge_link(aes(label = `Edge Type`), arrow = arrow(length = unit(3, 'mm')), end_cap = circle(3, 'mm'), alpha = 0.7) + #   geom_node_point(aes(color = `Node Type`), size = 5) + #   geom_node_text(aes(label = node_label), repel = TRUE, size = 3) + #   theme_void() ``

## Questions

```         
-   Can see when she released songs and what these songs any linkage to other songs or people and influence - can determine who influence her most

    -   from current graphs

        -   lyricalreferenceto - drowned harbour

        -   instyleof - the fittle & the fjord

        -   directlysamples and has been a member of - Ivy Echos
```

-   when did she team up with or collaborate with or write songs for different persons or groups

-   History of collaboration and timestamp with those she has worked with

-   

##Approach data cleaning show full chart of sailor shift

#### Prepatory Code for the visNetwork graph

```{r}
get_html_detail <- function(value, label) {
  if (!is.null(value) && !is.na(value) && as.character(value) != "") {
    return(paste0("<b>", label, ":</b> ", as.character(value), "<br>"))
  }
  return("")
}


# --- Simulate missing data/variables for a runnable example ---
if (!exists("inferred_genres_for_artistes")) {
  inferred_genres_for_artistes <- tibble(
    artiste_id = character(),
    inferred_genre = character()
  )
}

if (!exists("groups_for_visnetwork_combined")) {
  groups_for_visnetwork_combined <- tibble(
    id = names(all_node_type_colors),
    color = all_node_type_colors
  )
}
if (!exists("legend_edge_types_to_display")) {
  legend_edge_types_to_display <- desired_edge_types_to_display[desired_edge_types_to_display %in% names(all_edge_type_colors)]
}

# --- Improved release_date parsing and year extraction ---
nodes_tbl_cleaned <- nodes_tbl %>%
  mutate(id = as.character(id)) %>%
  mutate(id = trimws(id)) %>%
  mutate(id = tolower(id)) %>%
  distinct(id, .keep_all = TRUE) %>%
  mutate(
    release_date_parsed = suppressWarnings(parse_date_time(release_date, orders = c("ymd", "Ymd", "Y-m-d", "Y/m/d", "Y"))),
    release_year = ifelse(
      !is.na(release_date_parsed),
      year(release_date_parsed),
      suppressWarnings(as.integer(str_extract(as.character(release_date), "\\d{4}")))
    )
  )

if ("Node Type" %in% names(nodes_tbl_cleaned)) {
  nodes_tbl_cleaned <- nodes_tbl_cleaned %>%
    mutate(`Node Type` = trimws(`Node Type`))
} else {
  warning("Column 'Node Type' not found in nodes_tbl_cleaned. Node typing might be affected.")
  nodes_tbl_cleaned <- nodes_tbl_cleaned %>% mutate(`Node Type` = "Unknown")
}

if (!"notoriety_date" %in% names(nodes_tbl_cleaned) || all(is.na(nodes_tbl_cleaned$notoriety_date))) {
  set.seed(456)
  nodes_tbl_cleaned <- nodes_tbl_cleaned %>%
    mutate(
      temp_release_date = ymd(release_date, quiet = TRUE),
      notoriety_date = if_else(
        !is.na(temp_release_date) & sample(c(TRUE, FALSE), n(), replace = TRUE, prob = c(0.15, 0.85)),
        temp_release_date + days(sample(30:365, n(), replace = TRUE)),
        as.Date(NA)
      ),
      notoriety_year = year(notoriety_date)
    ) %>%
    select(-temp_release_date)
} else {
  nodes_tbl_cleaned <- nodes_tbl_cleaned %>%
    mutate(notoriety_year = suppressWarnings(as.integer(str_extract(as.character(notoriety_date), "\\d{4}"))))
}

if (!"notable" %in% names(nodes_tbl_cleaned)) {
  set.seed(123)
  nodes_tbl_cleaned <- nodes_tbl_cleaned %>%
    mutate(notable = sample(c(TRUE, FALSE), n(), replace = TRUE, prob = c(0.2, 0.8)))
}

if (!"stage_name" %in% names(nodes_tbl_cleaned)) {
  nodes_tbl_cleaned$stage_name <- NA_character_
}
if (!"genre" %in% names(nodes_tbl_cleaned)) {
  nodes_tbl_cleaned$genre <- NA_character_
}

# --- Identify Sailor Shift Node ---
target_name <- "Sailor Shift"
sailor_node <- nodes_tbl_cleaned %>% filter(tolower(name) == tolower(target_name))
if (nrow(sailor_node) == 0) stop(paste("No node named '", target_name, "' found.", sep=""))
sailor_id <- sailor_node$id

# --- Prepare Edges for visNetwork (and ensure IDs are consistent) ---
edges_df_for_igraph <- edges_tbl %>%
  rename(from = source, to = target) %>%
  mutate(across(c(from, to), as.character)) %>%
  mutate(across(c(from, to), trimws)) %>%
  mutate(across(c(from, to), tolower))

valid_node_ids_set <- unique(nodes_tbl_cleaned$id)
edges_df_for_igraph <- edges_df_for_igraph %>%
  filter(from %in% valid_node_ids_set & to %in% valid_node_ids_set)

# --- Outward Graph Logic ---
sailor_songs <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% desired_edge_types_to_display,
         from == sailor_id | to == sailor_id) %>%
  mutate(target_id = ifelse(from == sailor_id, to, from)) %>%
  inner_join(nodes_tbl_cleaned, by = c("target_id" = "id")) %>%
  filter(`Node Type` == "Song") %>%
  pull(target_id)

sailor_albums <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% desired_edge_types_to_display,
         from == sailor_id | to == sailor_id) %>%
  mutate(target_id = ifelse(from == sailor_id, to, from)) %>%
  inner_join(nodes_tbl_cleaned, by = c("target_id" = "id")) %>%
  filter(`Node Type` == "Album") %>%
  pull(target_id)

linked_out_targets <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% desired_edge_types_to_display,
         from %in% union(sailor_songs, sailor_albums)) %>%
  pull(to)

all_out_targets <- union(union(sailor_songs, sailor_albums), linked_out_targets)

contributors_to_targets <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% desired_edge_types_to_display,
         to %in% all_out_targets)

edges_from_sailor <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% desired_edge_types_to_display,
         from == sailor_id | from %in% union(sailor_songs, sailor_albums))

edges_outward_filtered <- bind_rows(edges_from_sailor, contributors_to_targets) %>%
  distinct(from, to, `Edge Type`, key)

outward_ids <- unique(c(edges_outward_filtered$from, edges_outward_filtered$to, sailor_id))

# --- Node Coloring Logic ---
min_release_year_for_gradient <- nodes_tbl_cleaned %>%
  filter(`Node Type` %in% c("Song", "Album") & id %in% outward_ids) %>%
  pull(release_year) %>%
  min(na.rm = TRUE)

max_release_year_for_gradient <- nodes_tbl_cleaned %>%
  filter(`Node Type` %in% c("Song", "Album") & id %in% outward_ids) %>%
  pull(release_year) %>%
  max(na.rm = TRUE)

color_palette_func <- colorRampPalette(rev(brewer.pal(9, "Blues"))) # Darker = larger year

song_palette_func <- colorRampPalette(brewer.pal(9, "YlOrRd"))   # Songs: yellow to red
album_palette_func <- colorRampPalette(brewer.pal(9, "PuBuGn"))  # Albums: purple to green/blue

min_song_year <- nodes_tbl_cleaned %>%
  filter(`Node Type` == "Song" & id %in% outward_ids) %>%
  pull(release_year) %>%
  min(na.rm = TRUE)

max_song_year <- nodes_tbl_cleaned %>%
  filter(`Node Type` == "Song" & id %in% outward_ids) %>%
  pull(release_year) %>%
  max(na.rm = TRUE)

min_album_year <- nodes_tbl_cleaned %>%
  filter(`Node Type` == "Album" & id %in% outward_ids) %>%
  pull(release_year) %>%
  min(na.rm = TRUE)

max_album_year <- nodes_tbl_cleaned %>%
  filter(`Node Type` == "Album" & id %in% outward_ids) %>%
  pull(release_year) %>%
  max(na.rm = TRUE)

nodes_outward_vis <- nodes_tbl_cleaned %>%
  filter(id %in% outward_ids) %>%
  left_join(inferred_genres_for_artistes, by = c("id" = "artiste_id")) %>%
  rowwise() %>%
  mutate(
    label = name,
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      get_html_detail(stage_name, "Stage Name"),
      get_html_detail(release_date, "Release Date"),
      get_html_detail(genre, "Genre (Node)"),
      get_html_detail(inferred_genre, "Genre (Inferred)"),
      get_html_detail(notable, "Notable")
    ),
    group = `Node Type`,
    size = case_when(
      id == sailor_id ~ 60,
      TRUE ~ 15
    ),
    shape = case_when(
      (`Node Type` %in% c("Song", "Album")) & notable ~ "star",
      TRUE ~ "dot"
    ),
    color.background = case_when(
      id == sailor_id ~ "gold",
      `Node Type` == "Song" & !is.na(release_year) ~ {
        if (min_song_year == max_song_year) {
          song_palette_func(1)[1]
        } else {
          scaled_year <- (release_year - min_song_year) / (max_song_year - min_song_year)
          scaled_year <- pmax(0, pmin(1, scaled_year))
          song_palette_func(100)[round(scaled_year * 99) + 1]
        }
      },
      `Node Type` == "Album" & !is.na(release_year) ~ {
        if (min_album_year == max_album_year) {
          album_palette_func(1)[1]
        } else {
          scaled_year <- (release_year - min_album_year) / (max_album_year - min_album_year)
          scaled_year <- pmax(0, pmin(1, scaled_year))
          album_palette_func(100)[round(scaled_year * 99) + 1]
        }
      },
      TRUE ~ unname(all_node_type_colors[as.character(`Node Type`)])
    ),
    color.background = ifelse(is.na(color.background), all_node_type_colors["Unknown"], color.background),
    color.border = "black",
    color.highlight.background = "red",
    color.highlight.border = "darkred",
    color.hover.background = "lightgray",
    color.hover.border = "darkgray"
  ) %>%
  ungroup()

edges_outward_final <- edges_outward_filtered %>%
  filter(from %in% nodes_outward_vis$id & to %in% nodes_outward_vis$id) %>%
  group_by(from, to) %>%
  summarise(
    aggregated_label = paste(sort(unique(`Edge Type`)), collapse = ", "),
    color = all_edge_type_colors[first(`Edge Type`)],
    arrows = "to",
    .groups = 'drop'
  ) %>%
  mutate(
    label = aggregated_label,
    title = aggregated_label,
    color = ifelse(is.na(color), all_edge_type_colors["default"], color)
  )

# --- Calculate degree for each node in the subgraph (without igraph) ---
degree_df <- edges_outward_final %>%
  select(from, to) %>%
  pivot_longer(cols = c(from, to), values_to = "id") %>%
  count(id, name = "degree")

# Optionally rescale for better visualization (e.g., between 15 and 60)
rescale <- function(x, to = c(15, 150)) {
  rng <- range(x, na.rm = TRUE)
  if (diff(rng) == 0) return(rep(mean(to), length(x)))
  (x - rng[1]) / diff(rng) * diff(to) + to[1]
}
degree_df$degree_scaled <- rescale(degree_df$degree)

# Join degree to nodes_outward_vis and update size
nodes_outward_vis <- nodes_outward_vis %>%
  left_join(degree_df, by = "id") %>%
  mutate(size = ifelse(id == sailor_id, 60, degree_scaled))
```

#### Rendering the Outward network graph

```{r}
graph_outward <- visNetwork(nodes_outward_vis, edges_outward_final,
                            main = paste0(target_name," 'Influenced By' Network Graph")) %>%
  visNodes(
    shadow = TRUE,
    font = list(size = 12),
    shape = "dot"
  ) %>%
  visEdges(
    arrows = "to",
    label = ~label,
    font = list(size = 10, align = "middle"),
    title = ~title,
    color = list(color = ~color, highlight = ~color),
    smooth = list(enabled = TRUE, type = "continuous", roundness = 0.5),
    width = 1
  ) %>%
  visOptions(
    highlightNearest = list(enabled = TRUE, degree = 1, hover = TRUE, algorithm = "hierarchical"),
    nodesIdSelection = list(enabled = TRUE, selected = sailor_id, useLabels = TRUE),
    selectedBy = "group"
  ) %>%
  {
    vis_obj <- .
    vis_obj <- vis_obj %>%
      visGroups(groupname = "Song", color = all_node_type_colors["Song"], shape = "dot") %>%
      visGroups(groupname = "Album", color = all_node_type_colors["Album"], shape = "dot") %>%
      visGroups(groupname = "Person", color = all_node_type_colors["Person"], shape = "dot") %>%
      visGroups(groupname = "MusicalGroup", color = all_node_type_colors["MusicalGroup"], shape = "dot") %>%
      visGroups(groupname = "RecordLabel", color = all_node_type_colors["RecordLabel"], shape = "dot") %>%
      visGroups(groupname = "Unknown", color = all_node_type_colors["Unknown"], shape = "dot")
    vis_obj
  } %>%
  # visLegend(main = "Node Types", useGroups = TRUE, position = "left", width = 0.15) %>%
  # visLegend(
  #   main = "Edge Types",
  #   addEdges = data.frame(
  #     color = all_edge_type_colors[legend_edge_types_to_display],
  #     label = legend_edge_types_to_display,
  #     font.align = "top"
  #   ),
  #   position = "right",
  #   width = 0.15
  # ) %>%
  visInteraction(navigationButtons = TRUE, keyboard = TRUE) %>%
  visIgraphLayout(layout = "layout_with_fr", randomSeed = 1234) %>%
  visPhysics(enabled = FALSE)

graph_outward

```
