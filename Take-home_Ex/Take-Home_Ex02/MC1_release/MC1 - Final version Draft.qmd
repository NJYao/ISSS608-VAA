---
title: "MC1"
date: "May 14, 2025"
date-modified: "last-modified"
author: "Ng Jin Yao"
format: 
  html:
    code-fold: true
    code-tools: true
editor: visual
execute: 
  eval: true
  echo: true
  warning: false
  freeze: true
---

::: callout-important
## Important

You are required to install the R packages above, if necessary, before continue to the next step\
Check packages to ensure they are installed
:::

## Visnetwork graph

plotting a visnetwork graph to visualise the interactions centering around sailor shift

### Step 1 :

Load Libraries

```{r}
library(dplyr)
library(igraph)
library(visNetwork)
library(jsonlite)
```

### Load Json Data

```{r}
# --- 1. Load your JSON data ---
# Assuming 'MC1_graph.json' is in your working directory
kg <- fromJSON("data/MC1_graph.json")
nodes_tbl <- as_tibble(kg$nodes)
edges_tbl <- as_tibble(kg$links)

```

### set filter and no. of hops

```{r}
# --- Configuration ---
target_name <- "Sailor Shift"
max_hops_for_context <- 3
```

### Defining edge type colors

```{r}
# --- Define ALL possible Edge Type Colors (Global and Consistent) ---
all_edge_type_colors <- c(
  "PerformerOf" = "#FF5733",
  "ComposerOf" = "#33FF57",
  "ProducerOf" = "#3357FF",
  "LyricistOf" = "#FF33F5",
  "RecordedBy" = "#F5FF33",
  "InterpolatesFrom" = "#8A2BE2",
  "InStyleOf" = "#DAA520",
  "LyricalReferenceTo" = "#5F9EA0",
  "CoverOf" = "#DC143C",
  "DirectlySamples" = "#6A5ACD",
  "DistributedBy" = "#20B2AA",
  "MemberOf" = "#8B4513",
  "default" = "#CCCCCC" # Fallback color for any unlisted type
)

# --- Define ALL possible Node Type Colors (Global and Consistent) ---
all_node_type_colors <- c(
  "Song" = "lightblue",
  "Person" = "orange",
  "MusicalGroup" = "#CF9FFF",
  "RecordLabel" = "lightgreen",
  "default" = "gray" # Fallback color for any unlisted type
)
```

### Select target node ID

```{r}
# --- Get target node ID ---
sailor_node <- nodes_tbl %>% filter(name == target_name)
if (nrow(sailor_node) == 0) stop(paste("No node named '", target_name, "' found.", sep=""))
sailor_id <- as.character(sailor_node$id)
```

### Preparing edges df for filtering and visnetwork

```{r}
# --- Prepare edges_igraph_df for filtering and visNetwork ---
edges_igraph_df <- edges_tbl %>%
  select(source, target, `Edge Type`, key) %>%
  mutate(across(c(source, target), as.character)) %>%
  rename(from = source, to = target) # Rename to from/to for visNetwork
```

### data preparation for visnetwork

```{r}
# --- Section 1: General Context Network (2-hop) ---
# Build igraph for neighborhood calculation
g <- graph_from_data_frame(edges_igraph_df, directed = FALSE)

```

```{r}
# Get N-hop neighborhood for general context
ego_nodes_indices <- ego(graph = g, order = max_hops_for_context, nodes = sailor_id, mode = "all")[[1]]
connected_ids_general <- names(ego_nodes_indices)
```

```{r}
# Filter nodes for the general context subgraph
sub_nodes_general <- nodes_tbl %>%
  filter(as.character(id) %in% connected_ids_general) %>%
  mutate(
    id = as.character(id),
    label = name,
    stage_name_str = if_else(!is.na(stage_name), paste0("<b>Stage Name:</b> ", stage_name, "<br>"), ""),
    release_date_str = if_else(!is.na(release_date), paste0("<b>Release Date:</b> ", release_date, "<br>"), ""),
    # Include genre information for the tooltip
    genre_str = if_else(!is.na(genre), paste0("<b>Genre:</b> ", genre, "<br>"), ""),
    notable_str = if_else(!is.na(notable), paste0("<b>Notable:</b> ", notable, "<br>"), ""),
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      genre_str, # Add genre to the tooltip
      stage_name_str,
      release_date_str,
      notable_str
    ),
    group = `Node Type`,
    # --- ADD THIS LINE TO CONTROL NODE SIZE ---
    size = ifelse(id == sailor_id, 50, 15) # Sailor Shift size 50, others 15
  ) %>%
  select(-stage_name_str, -release_date_str, -genre_str, -notable_str)
```

```{r}
# Filter edges for the general context subgraph and add color
sub_edges_general <- edges_igraph_df %>%
  filter(from %in% sub_nodes_general$id & to %in% sub_nodes_general$id) %>%
  mutate(color = all_edge_type_colors[`Edge Type`])
sub_edges_general$color[is.na(sub_edges_general$color)] <- all_edge_type_colors["default"]

```

### Generating Visnetwork graph

```{r}
# Visualize General Context Network
graph_general_context <- visNetwork(nodes = sub_nodes_general, edges = sub_edges_general,
                                    main = paste0("'", target_name, "' Network (", max_hops_for_context, "-hop Context)")) %>%
  visNodes(shape = "dot", size = 15, label = ~label, title = ~title) %>%
  visEdges(
    arrows = "to",
    label = ~`Edge Type`,
    font = list(size = 10, align = "middle"),
    color = list(color = ~color, highlight = ~color)
  ) %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = list(enabled = TRUE, selected = sailor_id)) %>%
  # Define node groups and their colors explicitly (needed for visLegend)
  visGroups(groupname = "Song", color = "lightblue") %>%
  visGroups(groupname = "Person", color = "orange") %>%
  visGroups(groupname = "RecordLabel", color = "lightgreen") %>%
  # Separate legend for nodes (on the left)
  visLegend(
    main = "Node Types",
    useGroups = TRUE, # Show node groups in this legend
    position = "left",
    width = 0.15 # Adjust width as needed
  ) %>%
  # Separate legend for edges (on the right)
  visLegend(
    main = "Edge Types",
    # Do not use useGroups or useEdges here as we are manually adding edges
    addEdges = data.frame(
      color = unname(all_edge_type_colors),
      label = names(all_edge_type_colors),
      font.align = "top" # Or "middle", "bottom"
    ),
    position = "right",
    width = 0.15 # Adjust width as needed
  ) %>%
  visIgraphLayout(layout = "layout_with_fr", randomSeed = 42)%>% # Apply FR layout
  visOptions(selectedBy = "group", 
             highlightNearest = TRUE, 
             nodesIdSelection = TRUE)

graph_general_context

```

### Optional - save as a html to view

```{r}
#| eval: false
visSave(graph_general_context, file = paste0(target_name, "_general_network_", max_hops_for_context, "hop.html"))
```

## 2 hop showing interactions between musical grp and ppl to sailor shift

able to see that a cluster of them are linked to sailor shift - dive deeper in following graphs

```{r}
# library(dplyr)
# library(jsonlite)
# library(igraph)
# library(visNetwork)
# library(viridisLite) # For the viridis color palette, used for group_colors
# 
# # --- 1. Load your JSON data ---
# # Assuming 'MC1_graph.json' is in your working directory
# kg <- fromJSON("data/MC1_graph.json")
# nodes_tbl <- as_tibble(kg$nodes)
# edges_tbl <- as_tibble(kg$links)
# 
# # --- Configuration ---
# target_name <- "Sailor Shift"

# --- Define the specific edge types for this new visualization ---
desired_edge_types_for_group_interactions <- c(
  "InterpolatesFrom",
  "DirectlySamples",
  "InStyleOf",
  "CoverOf",
  "LyricalReferenceTo",
  "MemberOf"
)


# --- IMPORTANT: Strict Node ID Cleaning ---
nodes_tbl_cleaned <- nodes_tbl %>%
  mutate(
    temp_numeric_id = as.numeric(as.character(id))
  ) %>%
  filter(!is.na(temp_numeric_id)) %>%
  mutate(id = as.character(temp_numeric_id)) %>%
  select(-temp_numeric_id)

# --- Get target node ID ---
sailor_node <- nodes_tbl_cleaned %>% filter(name == target_name)
if (nrow(sailor_node) == 0) stop(paste("No node named '", target_name, "' found in cleaned data.", sep=""))
sailor_id <- as.character(sailor_node$id)

# --- Prepare edges for igraph and visNetwork ---
edges_df_processed <- edges_tbl %>%
  select(source, target, `Edge Type`, key) %>%
  filter(source %in% nodes_tbl_cleaned$id & target %in% nodes_tbl_cleaned$id) %>%
  mutate(across(c(source, target), as.character)) %>%
  rename(from = source, to = target)

# --- Core Logic for the New Visualization ---

# 1. Filter edges to only include the desired interaction types
relevant_edges_for_group_interactions <- edges_df_processed %>%
  filter(`Edge Type` %in% desired_edge_types_for_group_interactions)

# 2. Identify all nodes (including Sailor Shift) connected by these specific edge types
nodes_connected_by_specific_edges <- unique(c(relevant_edges_for_group_interactions$from, relevant_edges_for_group_interactions$to))

# 3. Filter for 'MusicalGroup' and 'Person' nodes that are within this specific interaction context,
#    AND explicitly include 'Sailor Shift' node.
target_group_node_ids <- nodes_tbl_cleaned %>%
  filter(id %in% nodes_connected_by_specific_edges) %>%
  filter(`Node Type` %in% c("MusicalGroup", "Person")) %>%
  pull(id)

# Add sailor_id to the list of target group nodes
target_group_node_ids <- unique(c(target_group_node_ids, sailor_id))


# 4. Prepare the final nodes for the visualization
# This includes the identified 'MusicalGroup', 'Person', and 'Sailor Shift' nodes
nodes_for_new_vis <- nodes_tbl_cleaned %>%
  filter(id %in% target_group_node_ids) %>%
  mutate(
    id = as.character(id),
    label = name,
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      if_else(!is.na(stage_name), paste0("<b>Stage Name:</b> ", stage_name, "<br>"), ""),
      if_else(!is.na(release_date), paste0("<b>Release Date:</b> ", release_date, "<br>"), ""),
      if_else(!is.na(genre), paste0("<b>Genre:</b> ", genre, "<br>"), ""),
      if_else(!is.na(notable), paste0("<b>Notable:</b> ", notable, "<br>"), "")
    ),
    group = `Node Type`, # Group by Node Type for coloring/legend
    size = ifelse(id == sailor_id, 40, 20), # Make Sailor Shift node larger
     # First, get the base color from the global map based on Node Type
    base_color = all_node_type_colors[`Node Type`],
    # Handle cases where Node Type might not be in the map (will result in NA)
    base_color = ifelse(is.na(base_color), all_node_type_colors["default"], base_color),
    # Then, apply the specific color for Sailor Shift, overriding the base color
    color = ifelse(id == sailor_id, "gold", base_color)
  )

# 5. Prepare the final edges for the visualization
edges_for_new_vis <- relevant_edges_for_group_interactions %>%
  filter(from %in% nodes_for_new_vis$id & to %in% nodes_for_new_vis$id) %>%
  mutate(
    label = `Edge Type`,
    title = `Edge Type`,
    arrows = "to",
    color = all_edge_type_colors[`Edge Type`]
  )

# Ensure no NA colors if a type wasn't in `all_edge_type_colors`
edges_for_new_vis$color[is.na(edges_for_new_vis$color)] <- all_edge_type_colors["default"]

# --- IMPORTANT: Check if nodes or edges are empty before plotting ---
if (nrow(nodes_for_new_vis) == 0) {
  message("No nodes found for the specified filters. Cannot create the network graph.")
} else if (nrow(edges_for_new_vis) == 0) {
  message("No edges found for the specified filters between the selected nodes. The network graph will be empty or show only isolated nodes.")
} else {
  # --- Create the NEW visNetwork plot ---
  graph_group_interactions <- visNetwork(nodes = nodes_for_new_vis, edges = edges_for_new_vis,
                                         main = paste0("Interactions of '", target_name, "' with Musical Groups and Persons")) %>%
    visNodes(
      # UPDATED: Use the 'color' column for background color
      color = list(
        background = ~color,
        border = "black",
        highlight = list(background = "red", border = "darkred"),
        hover = list(background = "lightgray", border = "darkgray")
      ),
      shadow = TRUE,
      font = list(size = 12),
      shape = "dot"
    ) %>%
    visEdges(
      color = list(color = ~color, highlight = ~color),
      smooth = TRUE,
      shadow = TRUE,
      font = list(size = 10, align = "middle")
    ) %>%
    visOptions(
      highlightNearest = TRUE,
      nodesIdSelection = list(enabled = TRUE, selected = sailor_id),
      selectedBy = "group"
    ) %>%
    # Define node groups and their colors explicitly for the legend.
    # Note: Sailor Shift's explicit color will override its group color visually,
    # but it will still be part of its original 'Node Type' group in the dropdown/legend.
    # visGroups(groupname = "Person", color = "orange") %>%
    # visGroups(groupname = "MusicalGroup", color = "#CF9FFF") %>%
    # visGroups(groupname = "Song", color = "lightblue") %>%

    # Separate legend for nodes (on the left)
    visLegend(
      main = "Node Types",
      useGroups = TRUE,
      position = "left",
      width = 0.15
    ) %>%
    # Separate legend for edges (on the right)
    visLegend(
      main = "Edge Types",
      addEdges = data.frame(
        color = all_edge_type_colors[desired_edge_types_for_group_interactions],
        label = desired_edge_types_for_group_interactions,
        font.align = "top"
      ),
      position = "right",
      width = 0.15
    ) %>%
    visInteraction(
      navigationButtons = TRUE,
      keyboard = TRUE
    ) %>%
    visIgraphLayout(layout = "layout_with_fr", randomSeed = 42)

  # Save the network as an HTML file
  visSave(graph_group_interactions, file = paste0(target_name, "_group_interactions_with_sailor_shift_highlighted.html"))
}

  # Display the network
  graph_group_interactions
```

## 2 hop graph limiting the edges

next progrssion to limiting the edges and filter for those linked to sailor shift. However from the graph, we can see that there are songs with relationships as well. and missing linkages to the person or musical group that are linked to sailor shift - more edges need to be included

```{r}
# library(dplyr)
# library(jsonlite)
# library(igraph)
# library(visNetwork)
# library(viridisLite) # For the viridis color palette, used for group_colors
# 
# # --- 1. Load your JSON data ---
# # Assuming 'MC1_graph.json' is in your working directory
# kg <- fromJSON("data/MC1_graph.json")
# nodes_tbl <- as_tibble(kg$nodes)
# edges_tbl <- as_tibble(kg$links)
# 
# # --- Configuration ---
# target_name <- "Sailor Shift"
max_hops_for_context <- 2 # Define the maximum number of hops from Sailor Shift

# --- Define the specific edge types for this new visualization ---
desired_edge_types_for_group_interactions <- c(
  "InterpolatesFrom",
  "DirectlySamples",
  "InStyleOf",
  "CoverOf"
)


# --- IMPORTANT: Strict Node ID Cleaning ---
nodes_tbl_cleaned <- nodes_tbl %>%
  mutate(
    temp_numeric_id = as.numeric(as.character(id))
  ) %>%
  filter(!is.na(temp_numeric_id)) %>%
  mutate(id = as.character(temp_numeric_id)) %>%
  select(-temp_numeric_id)

# --- Get target node ID ---
sailor_node <- nodes_tbl_cleaned %>% filter(name == target_name)
if (nrow(sailor_node) == 0) stop(paste("No node named '", target_name, "' found in cleaned data.", sep=""))
sailor_id <- as.character(sailor_node$id)

# --- Prepare edges for igraph and visNetwork ---
edges_df_processed <- edges_tbl %>%
  select(source, target, `Edge Type`, key) %>%
  filter(source %in% nodes_tbl_cleaned$id & target %in% nodes_tbl_cleaned$id) %>%
  mutate(across(c(source, target), as.character)) %>%
  rename(from = source, to = target)

# --- Build igraph from full edges_df_processed for neighborhood calculation ---
g <- graph_from_data_frame(edges_df_processed, directed = FALSE) # Use directed = TRUE if your graph is truly directed for path finding

# --- Core Logic for the New Visualization with Hop Limit ---

# 1. Get nodes within N-hop neighborhood of Sailor Shift
ego_nodes_indices <- ego(graph = g, order = max_hops_for_context, nodes = sailor_id, mode = "all")[[1]]
connected_ids_within_hops <- names(ego_nodes_indices)

# 2. Filter edges to be within this N-hop neighborhood AND also be one of the desired interaction types
relevant_edges_for_display <- edges_df_processed %>%
  filter(from %in% connected_ids_within_hops & to %in% connected_ids_within_hops) %>% # Filter by hops first
  filter(`Edge Type` %in% desired_edge_types_for_group_interactions) # Then by specific edge types

# 3. Identify all nodes involved in these filtered edges
nodes_involved_in_filtered_edges <- unique(c(relevant_edges_for_display$from, relevant_edges_for_display$to))

# 4. Filter for ALL desired node types from the nodes involved in the filtered edges,
#    AND explicitly include 'Sailor Shift' node.
target_nodes_for_vis <- nodes_tbl_cleaned %>%
  filter(id %in% nodes_involved_in_filtered_edges) %>%
  filter(`Node Type` %in% c("Person", "Song", "RecordLabel", "Album", "MusicalGroup")) %>%
  pull(id)

# Add sailor_id to the list of target nodes for visualization
target_nodes_for_vis <- unique(c(target_nodes_for_vis, sailor_id))


# 5. Prepare the final nodes for the visualization
nodes_for_new_vis <- nodes_tbl_cleaned %>%
  filter(id %in% target_nodes_for_vis) %>%
  mutate(
    id = as.character(id),
    label = name,
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      if_else(!is.na(stage_name), paste0("<b>Stage Name:</b> ", stage_name, "<br>"), ""),
      if_else(!is.na(release_date), paste0("<b>Release Date:</b> ", release_date, "<br>"), ""),
      if_else(!is.na(genre), paste0("<b>Genre:</b> ", genre, "<br>"), ""),
      if_else(!is.na(notable), paste0("<b>Notable:</b> ", notable, "<br>"), "")
    ),
    group = `Node Type`,
    size = ifelse(id == sailor_id, 30, 20),
    base_color = all_node_type_colors[`Node Type`],
    base_color = ifelse(is.na(base_color), all_node_type_colors["default"], base_color),
    color = ifelse(id == sailor_id, "gold", base_color)
  ) %>%
  select(-base_color)

# For any node types not explicitly defined in all_node_type_colors, use the default
nodes_for_new_vis$color[is.na(nodes_for_new_vis$color)] <- all_node_type_colors["default"]


# 6. Prepare the final edges for the visualization
# Filter the 'relevant_edges_for_display' further to ensure both ends are in 'nodes_for_new_vis'
edges_for_new_vis <- relevant_edges_for_display %>%
  filter(from %in% nodes_for_new_vis$id & to %in% nodes_for_new_vis$id) %>%
  mutate(
    label = `Edge Type`,
    title = `Edge Type`,
    arrows = "to",
    color = all_edge_type_colors[`Edge Type`]
  )

# Ensure no NA colors if a type wasn't in `all_edge_type_colors`
edges_for_new_vis$color[is.na(edges_for_new_vis$color)] <- all_edge_type_colors["default"]

# --- IMPORTANT: Check if nodes or edges are empty before plotting ---
if (nrow(nodes_for_new_vis) == 0) {
  message("No nodes found for the specified filters and hop limit. Cannot create the network graph.")
} else if (nrow(edges_for_new_vis) == 0) {
  message("No edges found for the specified filters and hop limit between the selected nodes. The network graph will be empty or show only isolated nodes.")
} else {
  # --- Create the NEW visNetwork plot ---
  graph_group_interactions <- visNetwork(nodes = nodes_for_new_vis, edges = edges_for_new_vis,
                                         main = paste0("Interactions of '", target_name, "' (", max_hops_for_context, "-hop relevant connections)")) %>% # Updated title
    visNodes(
      color = list(
        background = ~color,
        border = "black",
        highlight = list(background = "red", border = "darkred"),
        hover = list(background = "lightgray", border = "darkgray")
      ),
      shadow = TRUE,
      font = list(size = 12),
      shape = "dot"
    ) %>%
    visEdges(
      color = list(color = ~color, highlight = ~color),
      smooth = TRUE,
      shadow = TRUE,
      font = list(size = 10, align = "middle")
    ) %>%
    visOptions(
      highlightNearest = TRUE,
      nodesIdSelection = list(enabled = TRUE, selected = sailor_id),
      selectedBy = "group"
    ) %>%
    # Define node groups and their colors explicitly for the legend using global map
    visGroups(groupname = "Person", color = all_node_type_colors["Person"]) %>%
    visGroups(groupname = "MusicalGroup", color = all_node_type_colors["MusicalGroup"]) %>%
    visGroups(groupname = "Song", color = all_node_type_colors["Song"]) %>%
    visGroups(groupname = "RecordLabel", color = all_node_type_colors["RecordLabel"]) %>%
    visGroups(groupname = "Album", color = all_node_type_colors["Album"]) %>%

    # Separate legend for nodes (on the left)
    visLegend(
      main = "Node Types",
      useGroups = TRUE,
      position = "left",
      width = 0.15
    ) %>%
    # Separate legend for edges (on the right)
    visLegend(
      main = "Edge Types",
      addEdges = data.frame(
        color = all_edge_type_colors[desired_edge_types_for_group_interactions],
        label = desired_edge_types_for_group_interactions,
        font.align = "top"
      ),
      position = "right",
      width = 0.15
    ) %>%
    visInteraction(
      navigationButtons = TRUE,
      keyboard = TRUE
    ) %>%
    visIgraphLayout(layout = "layout_with_fr", randomSeed = 42)
      }

#   # Save the network as an HTML file
#   visSave(graph_group_interactions, file = paste0(target_name, "_interactions_", max_hops_for_context, "hop_related_types_highlighted.html")) # Updated filename

  # Display the network
  graph_group_interactions

```

## another 2 hop graph reference

including more edge types to include into the graph to see more linkages between the person and muscial group, now including songs as well

```{r}
# library(dplyr)
# library(jsonlite)
# library(igraph)
# library(visNetwork)
# library(viridisLite) # For the viridis color palette, used for group_colors
# 
# # --- 1. Load your JSON data ---
# # Assuming 'MC1_graph.json' is in your working directory
# kg <- fromJSON("data/MC1_graph.json")
# nodes_tbl <- as_tibble(kg$nodes)
# edges_tbl <- as_tibble(kg$links)
# 
# # --- Configuration ---
# target_name <- "Sailor Shift"
max_hops_for_context <- 2 # Define the maximum number of hops from Sailor Shift

# --- Define the specific edge types for this new visualization ---
# These are the edge types that will be colored specifically and listed in the legend.
# If an edge type exists in the data but is NOT in this list, it will use 'default' color.
desired_edge_types_for_group_interactions <- c(
  "InterpolatesFrom",
  "DirectlySamples",
  "InStyleOf",
  "CoverOf",
  "PerformerOf",
  "ComposerOf",
  "ProducerOf",
  "LyricistOf",
  "RecordedBy",
  "LyricalReferenceTo",
  "DistributedBy",
  "MemberOf"
) # Including all common types for the legend to be comprehensive


# --- IMPORTANT: Strict Node ID Cleaning ---
nodes_tbl_cleaned <- nodes_tbl %>%
  mutate(
    temp_numeric_id = as.numeric(as.character(id))
  ) %>%
  filter(!is.na(temp_numeric_id)) %>%
  mutate(id = as.character(temp_numeric_id)) %>%
  select(-temp_numeric_id)

# --- Get target node ID ---
sailor_node <- nodes_tbl_cleaned %>% filter(name == target_name)
if (nrow(sailor_node) == 0) stop(paste("No node named '", target_name, "' found in cleaned data.", sep=""))
sailor_id <- as.character(sailor_node$id)

# --- Prepare edges for igraph and visNetwork ---
edges_df_processed <- edges_tbl %>%
  select(source, target, `Edge Type`, key) %>%
  filter(source %in% nodes_tbl_cleaned$id & target %in% nodes_tbl_cleaned$id) %>%
  mutate(across(c(source, target), as.character)) %>%
  rename(from = source, to = target)

# --- Build igraph from full edges_df_processed for neighborhood calculation ---
# Using directed = FALSE here unless your graph truly implies only one-way relationships
g <- graph_from_data_frame(edges_df_processed, directed = FALSE)

# --- Core Logic for the New Visualization with Hop Limit ---

# 1. Get nodes within N-hop neighborhood of Sailor Shift
ego_nodes_indices <- ego(graph = g, order = max_hops_for_context, nodes = sailor_id, mode = "all")[[1]]
connected_ids_within_hops <- names(ego_nodes_indices)

# 2. Filter ALL edges to be only within this N-hop neighborhood (no edge type filtering yet)
relevant_edges_for_display <- edges_df_processed %>%
  filter(from %in% connected_ids_within_hops & to %in% connected_ids_within_hops)

# 3. Identify all nodes involved in these filtered edges
nodes_involved_in_filtered_edges <- unique(c(relevant_edges_for_display$from, relevant_edges_for_display$to))

# 4. Filter for ALL desired node types from the nodes involved in the filtered edges,
#    AND explicitly include 'Sailor Shift' node.
target_nodes_for_vis <- nodes_tbl_cleaned %>%
  filter(id %in% nodes_involved_in_filtered_edges) %>%
  filter(`Node Type` %in% c("Person", "Song", "RecordLabel", "Album", "MusicalGroup")) %>%
  pull(id)

# Add sailor_id to the list of target nodes for visualization
target_nodes_for_vis <- unique(c(target_nodes_for_vis, sailor_id))


# 5. Prepare the final nodes for the visualization
nodes_for_new_vis <- nodes_tbl_cleaned %>%
  filter(id %in% target_nodes_for_vis) %>%
  mutate(
    id = as.character(id),
    label = name,
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      if_else(!is.na(stage_name), paste0("<b>Stage Name:</b> ", stage_name, "<br>"), ""),
      if_else(!is.na(release_date), paste0("<b>Release Date:</b> ", release_date, "<br>"), ""),
      if_else(!is.na(genre), paste0("<b>Genre:</b> ", genre, "<br>"), ""),
      if_else(!is.na(notable), paste0("<b>Notable:</b> ", notable, "<br>"), "")
    ),
    group = `Node Type`,
    size = ifelse(id == sailor_id, 40, 20),
    base_color = all_node_type_colors[`Node Type`],
    base_color = ifelse(is.na(base_color), all_node_type_colors["default"], base_color),
    color = ifelse(id == sailor_id, "gold", base_color)
  ) %>%
  select(-base_color)

# For any node types not explicitly defined in all_node_type_colors, use the default
nodes_for_new_vis$color[is.na(nodes_for_new_vis$color)] <- all_node_type_colors["default"]


# 6. Prepare the final edges for the visualization
# Filter the 'relevant_edges_for_display' further to ensure both ends are in 'nodes_for_new_vis'
edges_for_new_vis <- relevant_edges_for_display %>%
  filter(from %in% nodes_for_new_vis$id & to %in% nodes_for_new_vis$id) %>%
  mutate(
    label = `Edge Type`,
    title = `Edge Type`,
    arrows = "to",
    color = all_edge_type_colors[`Edge Type`] # Still use global edge type map for colors
  )

# Ensure no NA colors if a type wasn't in `all_edge_type_colors`
edges_for_new_vis$color[is.na(edges_for_new_vis$color)] <- all_edge_type_colors["default"]

# --- IMPORTANT: Check if nodes or edges are empty before plotting ---
if (nrow(nodes_for_new_vis) == 0) {
  message("No nodes found for the specified filters and hop limit. Cannot create the network graph.")
} else if (nrow(edges_for_new_vis) == 0) {
  message("No edges found for the specified filters and hop limit between the selected nodes. The network graph will be empty or show only isolated nodes.")
} else {
  # --- Create the NEW visNetwork plot ---
  graph_group_interactions <- visNetwork(nodes = nodes_for_new_vis, edges = edges_for_new_vis,
                                         main = paste0("Interactions of '", target_name, "' (", max_hops_for_context, "-hop All Relevant Connections)")) %>% # Updated title
    visNodes(
      color = list(
        background = ~color,
        border = "black",
        highlight = list(background = "red", border = "darkred"),
        hover = list(background = "lightgray", border = "darkgray")
      ),
      shadow = TRUE,
      font = list(size = 12),
      shape = "dot"
    ) %>%
    visEdges(
      color = list(color = ~color, highlight = ~color),
      smooth = TRUE,
      shadow = TRUE,
      font = list(size = 10, align = "middle")
    ) %>%
    visOptions(
      highlightNearest = TRUE,
      nodesIdSelection = list(enabled = TRUE, selected = sailor_id),
      selectedBy = "group"
    ) %>%
    # Define node groups and their colors explicitly for the legend using global map
    visGroups(groupname = "Person", color = all_node_type_colors["Person"]) %>%
    visGroups(groupname = "MusicalGroup", color = all_node_type_colors["MusicalGroup"]) %>%
    visGroups(groupname = "Song", color = all_node_type_colors["Song"]) %>%
    visGroups(groupname = "RecordLabel", color = all_node_type_colors["RecordLabel"]) %>%
    visGroups(groupname = "Album", color = all_node_type_colors["Album"]) %>%

    # Separate legend for nodes (on the left)
    visLegend(
      main = "Node Types",
      useGroups = TRUE,
      position = "left",
      width = 0.15
    ) %>%
    # Separate legend for edges (on the right)
    visLegend(
      main = "Edge Types",
      # Create data for edge legend based on actual edge types present in the graph
      addEdges = data.frame(
        edge_types_in_graph <- unique(edges_for_new_vis$`Edge Type`),
        color = all_edge_type_colors[edge_types_in_graph],
        label = edge_types_in_graph,
        font.align = "top"
      ),
      position = "right",
      width = 0.15
    ) %>%
    visInteraction(
      navigationButtons = TRUE,
      keyboard = TRUE
    ) %>%
    visIgraphLayout(layout = "layout_with_fr", randomSeed = 42)
  }
#   # Save the network as an HTML file
#   visSave(graph_group_interactions, file = paste0(target_name, "_interactions_", max_hops_for_context, "hop_all_edge_types_highlighted.html")) # Updated filename


  # Display the network
  graph_group_interactions


```

### Original 2 hop graph keep as reference - to show merging of edges for better display later on

```{r}
library(dplyr)
library(jsonlite)
library(igraph)
library(visNetwork)
library(viridisLite)
library(stringr)

# --- 1. Load your JSON data ---
kg <- fromJSON("data/MC1_graph.json")
nodes_tbl <- as_tibble(kg$nodes)
edges_tbl <- as_tibble(kg$links)

# --- Configuration ---
target_name <- "Sailor Shift"
max_hops_for_context <- 2 # Define the maximum number of hops from Sailor Shift for subgraph creation

# --- Define Global Colors ---
all_edge_type_colors <- c(
  "PerformerOf" = "#FF5733", "ComposerOf" = "#33FF57", "ProducerOf" = "#3357FF",
  "LyricistOf" = "#FF33F5", "RecordedBy" = "#F5FF33", "InterpolatesFrom" = "#8A2BE2",
  "InStyleOf" = "#DAA520", "LyricalReferenceTo" = "#5F9EA0", "CoverOf" = "#DC143C",
  "DirectlySamples" = "#6A5ACD", "DistributedBy" = "#20B2AA", "MemberOf" = "#8B4513",
  "default" = "#CCCCCC"
)
all_node_type_colors <- c(
  "Song" = "lightblue", "Person" = "orange", "MusicalGroup" = "purple",
  "RecordLabel" = "lightgreen", "Album" = "brown", "Oceanus Folk" = "#FFD700",
  "default_genre" = "#7FFF00",
  "default" = "gray"
)

# --- IMPORTANT: Strict Node ID Cleaning ---
nodes_tbl_cleaned <- nodes_tbl %>%
  mutate(
    id = as.character(id),
    id = trimws(id),
    temp_numeric_id = as.numeric(id)
  ) %>%
  filter(!is.na(temp_numeric_id)) %>%
  mutate(id = as.character(temp_numeric_id)) %>%
  select(-temp_numeric_id) %>%
  distinct(id, .keep_all = TRUE) %>%
  mutate(igraph_vertex_id = 1:n())

# --- Get target node ID (using the cleaned data and its igraph_vertex_id) ---
sailor_node <- nodes_tbl_cleaned %>%
  filter(name == target_name)

if (nrow(sailor_node) == 0) {
  stop(paste("No node named '", target_name, "' found in cleaned data.", sep = ""))
}
sailor_id <- as.character(sailor_node$id)
sailor_igraph_id <- as.character(sailor_node$igraph_vertex_id)

# --- Prepare edges for igraph (using igraph_vertex_id) ---
valid_original_node_ids <- nodes_tbl_cleaned$id

edges_df_processed <- edges_tbl %>%
  select(source, target, `Edge Type`, key) %>%
  filter(source %in% valid_original_node_ids & target %in% valid_original_node_ids) %>%
  mutate(
    source = as.character(source),
    target = as.character(target)
  ) %>%
  left_join(nodes_tbl_cleaned %>% select(id, igraph_vertex_id), by = c("source" = "id")) %>%
  rename(from = igraph_vertex_id) %>%
  left_join(nodes_tbl_cleaned %>% select(id, igraph_vertex_id), by = c("target" = "id")) %>%
  rename(to = igraph_vertex_id) %>%
  select(from, to, `Edge Type`, key) %>%
  filter(!is.na(from) & !is.na(to))

# --- Build igraph from full edges_df_processed for neighborhood calculation ---
g <- graph_from_data_frame(
  d = edges_df_processed %>% mutate(from = as.character(from), to = as.character(to)),
  directed = FALSE,
  vertices = as.character(nodes_tbl_cleaned$igraph_vertex_id)
)

# --- Core Logic for the New Visualization with Hop Limit ---
ego_nodes_indices <- ego(graph = g, order = max_hops_for_context, nodes = sailor_igraph_id, mode = "all")[[1]]
connected_igraph_ids_within_hops <- names(ego_nodes_indices)

relevant_edges_for_display <- edges_df_processed %>%
  filter(from %in% connected_igraph_ids_within_hops & to %in% connected_igraph_ids_within_hops)

nodes_involved_in_filtered_edges_igraph_ids <- unique(c(relevant_edges_for_display$from, relevant_edges_for_display$to))

target_nodes_for_vis_original_ids <- nodes_tbl_cleaned %>%
  filter(igraph_vertex_id %in% nodes_involved_in_filtered_edges_igraph_ids) %>%
  filter(`Node Type` %in% c("Person", "Song", "RecordLabel", "Album", "MusicalGroup")) %>%
  pull(id)

target_nodes_for_vis_original_ids <- unique(c(target_nodes_for_vis_original_ids, sailor_id))


# --- Helper function for safely adding details to node title ---
get_html_detail <- function(data_row, col_name, display_label) {
  if (col_name %in% names(data_row) && !is.na(data_row[[col_name]])) {
    return(paste0("<b>", display_label, ":</b> ", data_row[[col_name]], "<br>"))
  } else {
    return("")
  }
}

# --- Prepare the final nodes for the visualization ---
nodes_for_new_vis <- nodes_tbl_cleaned %>%
  filter(id %in% target_nodes_for_vis_original_ids) %>%
  rowwise() %>%
  mutate(
    id = as.character(id),
    label = name,
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      get_html_detail(cur_data(), "Stage Name", "Stage Name"),
      get_html_detail(cur_data(), "Release Date", "Release Date"),
      get_html_detail(cur_data(), "genre", "Genre"),
      get_html_detail(cur_data(), "notable", "Notable")
    ),
    group = `Node Type`,
    size = ifelse(id == sailor_id, 40, 20),
    base_color = all_node_type_colors[`Node Type`],
    base_color = ifelse(is.na(base_color), all_node_type_colors["default"], base_color),
    color = ifelse(id == sailor_id, "gold", base_color)
  ) %>%
  ungroup() %>%
  select(-base_color)

# --- Prepare the final edges for the visualization ---
edges_for_new_vis <- edges_tbl %>%
  select(source, target, `Edge Type`, key) %>%
  rename(from = source, to = target) %>%
  filter(from %in% nodes_for_new_vis$id & to %in% nodes_for_new_vis$id) %>%
  mutate(
    from = as.character(from),
    to = as.character(to),
    label = `Edge Type`,
    title = `Edge Type`,
    arrows = "to",
    color = all_edge_type_colors[`Edge Type`],
    color = ifelse(is.na(color), all_edge_type_colors["default"], color)
  )

# --- IMPORTANT: Check if nodes or edges are empty before plotting ---
if (nrow(nodes_for_new_vis) == 0) {
  message("No nodes found for the specified filters and hop limit. Cannot create the network graph.")
} else if (nrow(edges_for_new_vis) == 0) {
  message("No edges found for the specified filters and hop limit between the selected nodes. The network graph will be empty or show only isolated nodes.")
} else {
  # --- Create the NEW visNetwork plot ---
  graph_group_interactions <- visNetwork(nodes = nodes_for_new_vis, edges = edges_for_new_vis,
                                         main = paste0("Interactions of '", target_name, "' (", max_hops_for_context, "-hop Relevant Connections)")) %>%
    visNodes(
      color = list(
        background = ~color,
        border = "black",
        highlight = list(background = "red", border = "darkred"),
        hover = list(background = "lightgray", border = "darkgray")
      ),
      shadow = TRUE,
      font = list(size = 12),
      shape = "dot"
    ) %>%
    visEdges(
      color = list(color = ~color, highlight = ~color),
      smooth = TRUE,
      shadow = TRUE,
      font = list(size = 10, align = "middle")
    ) %>%
    visOptions(
      # *** CHANGE HERE: Removed 'degree = 2' ***
      highlightNearest = list(enabled = TRUE, degree = 1),
      nodesIdSelection = list(enabled = TRUE,selected = sailor_id),
      selectedBy = "group"
    )

  # Dynamically add visGroups for all unique node types present in the final graph
  unique_node_types_in_graph <- unique(nodes_for_new_vis$group)
  for (group_name in unique_node_types_in_graph) {
    if (group_name == "Sailor Shift" && sailor_node$name[1] == "Sailor Shift") {
      graph_group_interactions <- visGroups(graph_group_interactions, groupname = group_name, color = "gold")
    } else if (group_name %in% names(all_node_type_colors)) {
      graph_group_interactions <- visGroups(graph_group_interactions, groupname = group_name, color = all_node_type_colors[group_name])
    } else {
      graph_group_interactions <- visGroups(graph_group_interactions, groupname = group_name, color = all_node_type_colors["default"])
    }
  }

  graph_group_interactions <- graph_group_interactions %>%
    visLegend(
      main = "Node Types",
      useGroups = TRUE,
      position = "left",
      width = 0.15
    ) %>%
    visLegend(
      main = "Edge Types",
      addEdges = data.frame(
        edge_types_in_graph = unique(edges_for_new_vis$`Edge Type`),
        color = all_edge_type_colors[unique(edges_for_new_vis$`Edge Type`)],
        label = unique(edges_for_new_vis$`Edge Type`),
        font.align = "top"
      ),
      position = "right",
      width = 0.15
    ) %>%
    visInteraction(
      navigationButtons = TRUE,
      keyboard = TRUE
    ) %>%
    visIgraphLayout(layout = "layout_with_fr", randomSeed = 42)

  # Display the network
  graph_group_interactions

  # Optional: Save the network as an HTML file
  # visSave(graph_group_interactions, file = paste0(target_name, "_interactions_", max_hops_for_context, "hop_all_edge_types_highlighted.html"))
}

```

# Aggregate edges to account for overlap - final over view graphs

During the generating of graph, 1 important improvement - there are overlapping edges blocking one another.

## 2 hop interaction graph with aggregated edges

flatten the edges - issue of overlapping edges, this can be solved by aggregating the edges together, and so when labelling, it will display both links seperated by a comma to show the 2 relation or link

```{r}
# Libraries
library(dplyr)
library(jsonlite)
library(igraph)
library(visNetwork)
library(viridisLite)
library(stringr)

# --- 1. Load your JSON data ---
kg <- fromJSON("data/MC1_graph.json")
nodes_tbl <- as_tibble(kg$nodes)
edges_tbl <- as_tibble(kg$links)

# --- Configuration ---
target_name <- "Sailor Shift"
max_hops_for_context <- 2 # Maximum number of hops for the subgraph

# --- Define Global Colors for Node Types ---
# IMPORTANT: Genres will NOT have individual colors here. All 'Song' nodes
# will take the 'Song' color.
# all_node_type_colors <- c(
#   "Song" = "lightblue",
#   "Person" = "orange",
#   "MusicalGroup" = "purple",
#   "RecordLabel" = "lightgreen",
#   "Album" = "brown",
#   # Add other Node Types if they exist in your data and you want specific colors
#   # E.g., if "Oceanus Folk" is a Node Type, not just a genre:
#   # "Oceanus Folk" = "#FFD700",
#   "default" = "gray" # Fallback for any unmapped Node Types
# )
# 
# # --- Define Global Colors for Edge Types ---
# all_edge_type_colors <- c(
#   "PerformerOf" = "#FF5733", "ComposerOf" = "#33FF57", "ProducerOf" = "#3357FF",
#   "LyricistOf" = "#FF33F5", "RecordedBy" = "#F5FF33", "InterpolatesFrom" = "#8A2BE2",
#   "InStyleOf" = "#DAA520", "LyricalReferenceTo" = "#5F9EA0", "CoverOf" = "#DC143C",
#   "DirectlySamples" = "#6A5ACD", "DistributedBy" = "#20B2AA", "MemberOf" = "#8B4513",
#   "default" = "#CCCCCC" # Fallback for unlisted edge types
# )

# --- Define which edge types to display and include in the legend (for aggregation) ---
desired_edge_types_to_display <- c(
  "InterpolatesFrom",
  "DirectlySamples",
  "InStyleOf",
  "CoverOf",
  "LyricalReferenceTo",
  "ProducerOf",
  "ComposerOf",
  "PerformerOf",
  "LyricistOf",
  "MemberOf"
)

# --- Strict Node ID Cleaning ---
nodes_tbl_cleaned <- nodes_tbl %>%
  mutate(
    temp_numeric_id = as.numeric(as.character(id))
  ) %>%
  filter(!is.na(temp_numeric_id)) %>%
  mutate(id = as.character(temp_numeric_id)) %>%
  select(-temp_numeric_id) %>%
  distinct(id, .keep_all = TRUE)

# --- Get target node ID from the cleaned nodes table ---
sailor_node <- nodes_tbl_cleaned %>% filter(name == target_name)
if (nrow(sailor_node) == 0) stop(paste("No node named '", target_name, "' found in cleaned data.", sep=""))
sailor_id <- as.character(sailor_node$id)

# --- Prepare edges for igraph (using original IDs) ---
valid_original_node_ids <- nodes_tbl_cleaned$id

edges_df_for_igraph <- edges_tbl %>%
  select(source, target, `Edge Type`, key) %>%
  filter(source %in% valid_original_node_ids & target %in% valid_original_node_ids) %>%
  mutate(across(c(source, target), as.character)) %>%
  rename(from = source, to = target)

# --- Build full igraph with directed = TRUE ---
g_full <- graph_from_data_frame(edges_df_for_igraph, directed = TRUE, vertices = nodes_tbl_cleaned$id)

# --- Get N-hop neighborhood (2-hop overall context) ---
ego_nodes_indices_overall <- ego(graph = g_full, order = max_hops_for_context, nodes = sailor_id, mode = "all")[[1]]
connected_ids_overall <- names(ego_nodes_indices_overall)

# --- Helper function for safely adding details to node title ---
get_html_detail <- function(data_row, col_name, display_label) {
  if (col_name %in% names(data_row) && !is.na(data_row[[col_name]])) {
    return(paste0("<b>", display_label, ":</b> ", data_row[[col_name]], "<br>"))
  } else {
    return("")
  }
}

# --- Prepare the final nodes for the visualization (Coloring by Node Type) ---
nodes_for_combined_vis <- nodes_tbl_cleaned %>%
  filter(id %in% connected_ids_overall) %>%
  rowwise() %>% # Process row by row for dynamic title generation
  mutate(
    id = as.character(id),
    label = name,
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      get_html_detail(cur_data(), "Stage Name", "Stage Name"),
      get_html_detail(cur_data(), "Release Date", "Release Date"),
      get_html_detail(cur_data(), "genre", "Genre"), # Genre can still be in tooltip
      get_html_detail(cur_data(), "notable", "Notable")
    ),
    # Group nodes explicitly by Node Type for filtering and consistent coloring
    group = `Node Type`,
    size = ifelse(id == sailor_id, 50, 15), # Sailor Shift node larger
    # Determine node color based on 'Node Type' and Sailor Shift override
    base_color = all_node_type_colors[`Node Type`],
    node_display_color = ifelse(is.na(base_color), all_node_type_colors["default"], base_color),
    node_display_color = ifelse(id == sailor_id, "gold", node_display_color) # Sailor Shift is gold
  ) %>%
  ungroup() %>%
  select(-base_color)


# --- Prepare Edges for visNetwork (AGGREGATED) ---
sub_edges_combined <- edges_df_for_igraph %>%
  filter(from %in% nodes_for_combined_vis$id & to %in% nodes_for_combined_vis$id) %>%
  filter(`Edge Type` %in% desired_edge_types_to_display) %>%
  # --- AGGREGATE EDGES HERE ---
  group_by(from, to) %>%
  summarise(
    aggregated_label = paste(sort(unique(`Edge Type`)), collapse = ", "),
    color = all_edge_type_colors[first(`Edge Type`)], # Color based on the first edge type
    arrows = "to",
    .groups = 'drop'
  ) %>%
  mutate(
    label = aggregated_label, # Use the combined label for display
    title = aggregated_label # Use the combined label for hover tooltip
  ) %>%
  # Ensure no NA colors if a type wasn't in `all_edge_type_colors`
  mutate(color = ifelse(is.na(color), all_edge_type_colors["default"], color))


# --- IMPORTANT: Check if nodes or edges are empty before plotting ---
if (nrow(nodes_for_combined_vis) == 0) {
  message("No nodes found for the specified filters. Cannot create the network graph.")
} else if (nrow(sub_edges_combined) == 0) {
  message("No edges found for the specified filters between the selected nodes. The network graph will be empty or show only isolated nodes.")
} else {
  # --- Create the visNetwork plot ---
  graph_combined_context <- visNetwork(nodes = nodes_for_combined_vis, edges = sub_edges_combined,
                                       main = paste0("'", target_name, "' Network (2-hop Context by Node Type, Aggregated Edge Types)")) %>%
    visNodes(
      color = list(
        background = ~node_display_color, # Use the calculated display color
        border = "black",
        highlight = list(background = "red", border = "darkred"),
        hover = list(background = "lightgray", border = "darkgray")
      ),
      shadow = TRUE,
      font = list(size = 12),
      shape = "dot"
    ) %>%
    visEdges(
      arrows = "to",
      label = ~label, # Use the aggregated label
      font = list(size = 10, align = "middle"),
      title = ~title, # Use aggregated label for hover
      color = list(color = ~color, highlight = ~color),
      smooth = list(enabled = TRUE, type = "continuous", roundness = 0.5), # Static smoothing
      width = 1
    ) %>%
    visOptions(
      highlightNearest = TRUE,
      nodesIdSelection = list(enabled = TRUE, selected = sailor_id, useLabels = TRUE),
      selectedBy = "group" # Now filters by Node Type (Song, Person, Album, etc.)
    ) %>%
    # # Define node groups and their colors explicitly for the legend (visGroups) based on Node Type
    # visGroups(groupname = "Song", color = all_node_type_colors["Song"]) %>%
    # visGroups(groupname = "Person", color = all_node_type_colors["Person"]) %>%
    # visGroups(groupname = "MusicalGroup", color = all_node_type_colors["MusicalGroup"]) %>%
    # visGroups(groupname = "RecordLabel", color = all_node_type_colors["RecordLabel"]) %>%
    # visGroups(groupname = "Album", color = all_node_type_colors["Album"]) %>%
    # Add any other Node Types from your data that you want in the legend
    # For any group not explicitly listed here, visNetwork might assign a default color in the legend
    # unless you add it here.
    visGroups(groupname = "default", color = all_node_type_colors["default"]) %>% # Ensure default color is in legend

    # Legend (on the left)
    visLegend(
      main = "Node Types", # Now clearly states "Node Types"
      useGroups = TRUE,
      position = "left",
      width = 0.15
    ) %>%
    # --- Edge Legend: Show original edge types, not aggregated labels ---
    visLegend(
      main = "Edge Types",
      addEdges = data.frame(
        color = all_edge_type_colors[desired_edge_types_to_display],
        label = desired_edge_types_to_display,
        font.align = "top"
      ),
      position = "right",
      width = 0.15
    ) %>%
    visInteraction(
      navigationButtons = TRUE,
      keyboard = TRUE
    ) %>%
    # Apply initial igraph layout (static)
    visIgraphLayout(layout = "layout_with_fr", randomSeed = 1234) %>%
    # Explicitly disable physics to make the graph static
    visPhysics(enabled = FALSE)

  # Display the network
  graph_combined_context

  # Optional: Save the network as an HTML file
  # visSave(graph_combined_context, file = paste0(target_name, "_combined_nodetype_colors_", max_hops_for_context, "hop.html"))
}
```

Improved version:

The above version only stop the linkage at 3 hops, but for some at the 3rd hop, it ends at a song and does not inform us who is related to that song.

Additionally, there is no information on the genre that the person or musical group performed, we can add in the inferred genre that they sing by inferring from the songs they have performed before.

```{r}
# Libraries
library(dplyr)
library(jsonlite)
library(igraph)
library(visNetwork)
library(viridisLite)
library(stringr)

# --- 1. Load your JSON data ---
kg <- fromJSON("data/MC1_graph.json")
nodes_tbl <- as_tibble(kg$nodes)
edges_tbl <- as_tibble(kg$links)

# --- Configuration ---
target_name <- "Sailor Shift"
max_hops_for_context <- 2 # Maximum number of hops for the subgraph
graph_title <- paste0("'", target_name, "' Network (2-hop Context with Inferred Artiste Genres & Aggregated Edge Types)")

# --- Define Global Colors for Node Types ---
all_node_type_colors <- c(
  "Song" = "lightblue",
  "Person" = "orange",
  "MusicalGroup" = "purple",
  "RecordLabel" = "lightgreen",
  "Album" = "brown",
  "default" = "gray" # Fallback for any unmapped Node Types
)

# --- Define Global Colors for Edge Types ---
all_edge_type_colors <- c(
  "PerformerOf" = "#FF5733", "ComposerOf" = "#33FF57", "ProducerOf" = "#3357FF",
  "LyricistOf" = "#FF33F5", "RecordedBy" = "#F5FF33", "InterpolatesFrom" = "#8A2BE2",
  "InStyleOf" = "#DAA520", "LyricalReferenceTo" = "#5F9EA0", "CoverOf" = "#DC143C",
  "DirectlySamples" = "#6A5ACD", "DistributedBy" = "#20B2AA", "MemberOf" = "#8B4513",
  "default" = "#CCCCCC" # Fallback for unlisted edge types
)

# --- Define which edge types to display and include in the legend (for aggregation) ---
desired_edge_types_to_display <- c(
  "InterpolatesFrom",
  "DirectlySamples",
  "InStyleOf",
  "CoverOf",
  "LyricalReferenceTo",
  "ProducerOf",
  "ComposerOf",
  "PerformerOf",
  "LyricistOf",
  "MemberOf"
)

# --- Strict Node ID Cleaning ---
nodes_tbl_cleaned <- nodes_tbl %>%
  mutate(id = as.character(id)) %>% # Convert original ID to character first
  mutate(id = trimws(id)) %>%       # Trim whitespace from character IDs
  mutate(temp_numeric_id = suppressWarnings(as.numeric(id))) %>% # suppressWarnings to avoid warnings for NAs
  filter(!is.na(temp_numeric_id)) %>% # Keep only IDs that successfully converted to numeric
  mutate(id = as.character(temp_numeric_id)) %>% # Convert numeric back to character for consistent IDs
  select(-temp_numeric_id) %>% # Remove the temporary column
  distinct(id, .keep_all = TRUE) %>% # Ensure unique IDs based on the cleaned ID
  mutate(`Node Type` = trimws(`Node Type`)) # Clean Node Type strings

# --- Get target node ID from the cleaned nodes table ---
sailor_node <- nodes_tbl_cleaned %>% filter(name == trimws(target_name))
if (nrow(sailor_node) == 0) stop(paste("No node named '", target_name, "' found in cleaned data.", sep=""))
sailor_id <- as.character(sailor_node$id)

# --- Prepare edges for igraph (using original IDs) ---
valid_original_node_ids <- nodes_tbl_cleaned$id

edges_df_for_igraph <- edges_tbl %>%
  select(source, target, `Edge Type`, key) %>%
  filter(source %in% valid_original_node_ids & target %in% valid_original_node_ids) %>%
  mutate(across(c(source, target), as.character)) %>%
  rename(from = source, to = target)

# --- DIAGNOSTIC CHECK: Ensure no duplicate vertex IDs before building igraph ---
if (any(duplicated(nodes_tbl_cleaned$id))) {
  duplicate_ids <- nodes_tbl_cleaned$id[duplicated(nodes_tbl_cleaned$id)]
  stop(paste("FATAL ERROR: Duplicate node IDs found in 'nodes_tbl_cleaned$id' even after cleaning. Duplicates: ",
             paste(unique(duplicate_ids), collapse = ", "),
             ". Please inspect your original 'MC1_graph.json' data for these IDs.", sep=""))
}

# --- Build full igraph with directed = TRUE ---
g_full <- graph_from_data_frame(edges_df_for_igraph, directed = TRUE, vertices = nodes_tbl_cleaned$id)

# --- Get N-hop neighborhood (2-hop overall context) ---
ego_nodes_indices_overall <- ego(graph = g_full, order = max_hops_for_context, nodes = sailor_id, mode = "all")[[1]]
connected_ids_overall <- names(ego_nodes_indices_overall)

# --- NEW: Infer Genres for Person/MusicalGroup Nodes ---
genre_inference_edge_types <- c("PerformerOf", "ComposerOf", "ProducerOf", "LyricistOf", "RecordedBy")

artiste_song_genre_links <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% genre_inference_edge_types) %>%
  inner_join(nodes_tbl_cleaned %>% select(id, `Node Type`, genre),
             by = c("to" = "id")) %>%
  filter(`Node Type` == "Song") %>% # Ensure the target node is a Song
  select(artiste_id = from, song_genre = genre) %>%
  filter(!is.na(song_genre) & song_genre != "") # Only consider songs with a defined genre

inferred_genres_for_artistes <- artiste_song_genre_links %>%
  group_by(artiste_id) %>%
  summarise(
    inferred_genre = paste(sort(unique(song_genre)), collapse = ", "),
    .groups = 'drop'
  )

# --- Helper function for safely adding details to node title ---
get_html_detail <- function(data_row, col_name, display_label) {
  if (col_name %in% names(data_row) && !is.na(data_row[[col_name]]) && data_row[[col_name]] != "") { # Added check for empty string
    return(paste0("<b>", display_label, ":</b> ", data_row[[col_name]], "<br>"))
  } else {
    return("")
  }
}

# --- Prepare the final nodes for the visualization (Coloring by Node Type) ---
nodes_for_combined_vis <- nodes_tbl_cleaned %>%
  filter(id %in% connected_ids_overall) %>%
  # Left join inferred genres to Person/MusicalGroup nodes
  left_join(inferred_genres_for_artistes, by = c("id" = "artiste_id")) %>%
  rowwise() %>% # Process row by row for dynamic title generation
  mutate(
    id = as.character(id),
    label = name,
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      get_html_detail(cur_data(), "stage_name", "Stage Name"),
      get_html_detail(cur_data(), "release_date", "Release Date"),
      get_html_detail(cur_data(), "genre", "Genre (Node)"), # Original node genre if exists
      get_html_detail(cur_data(), "inferred_genre", "Genre (Inferred)"), # New inferred genre
      get_html_detail(cur_data(), "notable", "Notable")
    ),
    # Group nodes explicitly by Node Type for filtering and consistent coloring
    group = `Node Type`,
    size = ifelse(id == sailor_id, 50, 15), # Sailor Shift node larger
    # Determine node color based on 'Node Type' and Sailor Shift override
    base_color = all_node_type_colors[`Node Type`],
    node_display_color = ifelse(is.na(base_color), all_node_type_colors["default"], base_color),
    node_display_color = ifelse(id == sailor_id, "gold", node_display_color) # Sailor Shift is gold
  ) %>%
  ungroup() %>%
  select(-base_color)


# --- Prepare Edges for visNetwork (AGGREGATED) ---
sub_edges_combined <- edges_df_for_igraph %>%
  filter(from %in% nodes_for_combined_vis$id & to %in% nodes_for_combined_vis$id) %>%
  filter(`Edge Type` %in% desired_edge_types_to_display) %>%
  # --- AGGREGATE EDGES HERE ---
  group_by(from, to) %>%
  summarise(
    aggregated_label = paste(sort(unique(`Edge Type`)), collapse = ", "),
    color = all_edge_type_colors[first(`Edge Type`)], # Color based on the first edge type
    arrows = "to",
    .groups = 'drop'
  ) %>%
  mutate(
    label = aggregated_label, # Use the combined label for display
    title = aggregated_label # Use the combined label for hover tooltip
  ) %>%
  # Ensure no NA colors if a type wasn't in `all_edge_type_colors`
  mutate(color = ifelse(is.na(color), all_edge_type_colors["default"], color))


# --- Prepare groups for visGroups (robust legend) ---
actual_node_groups_combined <- unique(nodes_for_combined_vis$group)
actual_node_groups_combined <- actual_node_groups_combined[!is.na(actual_node_groups_combined) & actual_node_groups_combined != ""]

if (length(actual_node_groups_combined) == 0) {
  message("Warning: No valid node groups found for visGroups. Legend might not display correctly.")
  groups_for_visnetwork_combined <- data.frame(id = character(0), color = character(0), label = character(0), stringsAsFactors = FALSE)
} else {
  groups_for_visnetwork_combined <- data.frame(
    id = actual_node_groups_combined,
    color = as.character(sapply(actual_node_groups_combined, function(g) {
      if (!is.na(all_node_type_colors[g])) {
        return(all_node_type_colors[g])
      } else {
        return(all_node_type_colors["default"])
      }
    })),
    label = actual_node_groups_combined,
    stringsAsFactors = FALSE
  )
}


# --- IMPORTANT: Check if nodes or edges are empty before plotting ---
if (nrow(nodes_for_combined_vis) == 0) {
  message("No nodes found for the specified filters. Cannot create the network graph.")
} else if (nrow(sub_edges_combined) == 0) {
  message("No edges found for the specified filters between the selected nodes. The network graph will be empty or show only isolated nodes.")
} else {
  # --- Prepare data for the Edge Legend ---
  legend_edge_types_to_display <- names(all_edge_type_colors)[names(all_edge_type_colors) != "default"]

  # --- Create the visNetwork plot ---
  graph_combined_context <- visNetwork(nodes = nodes_for_combined_vis, edges = sub_edges_combined,
                                       main = graph_title) %>%
    visNodes(
      color = list(
        background = ~node_display_color, # Use the calculated display color
        border = "black",
        highlight = list(background = "red", border = "darkred"),
        hover = list(background = "lightgray", border = "darkgray")
      ),
      shadow = TRUE,
      font = list(size = 12),
      shape = "dot"
    ) %>%
    visEdges(
      arrows = "to",
      label = ~label, # Use the aggregated label
      font = list(size = 10, align = "middle"),
      title = ~title, # Use aggregated label for hover
      color = list(color = ~color, highlight = ~color),
      smooth = list(enabled = TRUE, type = "continuous", roundness = 0.5), # Static smoothing
      width = 1
    ) %>%
    visOptions(
      highlightNearest = TRUE,
      nodesIdSelection = list(enabled = TRUE, selected = sailor_id, useLabels = TRUE),
      selectedBy = "group" # Now filters by Node Type (Song, Person, Album, etc.)
    ) %>%
    # Apply visGroups for each group found in our prepared data frame
    {
      temp_vis_object <- .
      for (i in 1:nrow(groups_for_visnetwork_combined)) {
        group_id <- groups_for_visnetwork_combined$id[i]
        group_color <- groups_for_visnetwork_combined$color[i]
        temp_vis_object <- temp_vis_object %>%
          visGroups(groupname = group_id, color = group_color)
      }
      temp_vis_object
    } %>% # End of the curly braces block
    visLegend(
      main = "Node Types", # Now clearly states "Node Types"
      useGroups = TRUE,
      position = "left",
      width = 0.15
    ) %>%
    # --- Edge Legend: Show original edge types, not aggregated labels ---
    visLegend(
      main = "Edge Types",
      addEdges = data.frame(
        color = all_edge_type_colors[legend_edge_types_to_display],
        label = legend_edge_types_to_display,
        font.align = "top"
      ),
      position = "right",
      width = 0.15
    ) %>%
    visInteraction(
      navigationButtons = TRUE,
      keyboard = TRUE
    ) %>%
    # Apply initial igraph layout (static)
    visIgraphLayout(layout = "layout_with_fr", randomSeed = 1234) %>%
    # Explicitly disable physics to make the graph static
    visPhysics(enabled = FALSE)

  # Display the network
  graph_combined_context

  # Optional: Save the network as an HTML file
  # visSave(graph_combined_context, file = paste0(target_name, "_combined_nodetype_colors_", max_hops_for_context, "hop.html"))
}
```

## Outward link influence to

to make it less cluttered, we split the graph into 2, one for who outward, who sailor shift influenced and inward for who influenced sailor shift

added different colors for the genre of songs

```{r}
# Libraries
library(dplyr)
library(jsonlite)
library(igraph)
library(visNetwork)
library(viridisLite) # For viridis palette (though not directly used, kept for consistency if planned)
library(stringr)

# --- 1. Load your JSON data ---
# Assuming 'MC1_graph.json' is in your working directory
kg <- fromJSON("data/MC1_graph.json")
nodes_tbl <- as_tibble(kg$nodes)
edges_tbl <- as_tibble(kg$links)

# --- Global Colors (consistent with previous versions, necessary for this code) ---
# all_edge_type_colors <- c(
#   "PerformerOf" = "#FF5733", "ComposerOf" = "#33FF57", "ProducerOf" = "#3357FF",
#   "LyricistOf" = "#FF33F5", "RecordedBy" = "#F5FF33", "InterpolatesFrom" = "#8A2BE2",
#   "InStyleOf" = "#DAA520", "LyricalReferenceTo" = "#5F9EA0", "CoverOf" = "#DC143C",
#   "DirectlySamples" = "#6A5ACD", "DistributedBy" = "#20B2AA", "MemberOf" = "#8B4513",
#   "default" = "#CCCCCC" # Fallback for unlisted edge types
# )
# all_node_type_colors <- c(
#   "Song" = "lightblue", "Person" = "orange", "MusicalGroup" = "purple",
#   "RecordLabel" = "lightgreen", "Album" = "brown", "Oceanus Folk" = "#FFD700",
#   "default_genre" = "#7FFF00", # Fallback for unlisted genres
#   "default" = "gray" # Fallback for unlisted node types
# )

# --- Configuration ---
target_name <- "Sailor Shift"
max_hops_for_context <- 2 # For 2-hop neighborhood

# --- NEW: Define which edge types to display and include in the legend ---
# Only these specific edge types will be considered for aggregation
desired_edge_types_to_display <- c(
  "InterpolatesFrom",
  "DirectlySamples",
  "InStyleOf",
  "CoverOf",
  "LyricalReferenceTo",
  "ProducerOf",
  "ComposerOf",
  "PerformerOf",
  "LyricistOf",
  "MemberOf"
)

# --- IMPORTANT: Strict Node ID Cleaning ---
nodes_tbl_cleaned <- nodes_tbl %>%
  mutate(
    temp_numeric_id = as.numeric(as.character(id))
  ) %>%
  filter(!is.na(temp_numeric_id)) %>%
  mutate(id = as.character(temp_numeric_id)) %>%
  select(-temp_numeric_id) %>%
  distinct(id, .keep_all = TRUE) # Ensure unique IDs after cleaning

# --- Get target node ID from the cleaned nodes table ---
sailor_node <- nodes_tbl_cleaned %>% filter(name == target_name)
if (nrow(sailor_node) == 0) stop(paste("No node named '", target_name, "' found in cleaned data.", sep=""))
sailor_id <- as.character(sailor_node$id)

# --- IMPORTANT: Pre-filter edges to ensure valid source/target IDs ---
valid_node_ids <- nodes_tbl_cleaned$id

edges_df_for_igraph <- edges_tbl %>%
  select(source, target, `Edge Type`, key) %>%
  filter(source %in% valid_node_ids & target %in% valid_node_ids) %>%
  mutate(across(c(source, target), as.character)) %>%
  rename(from = source, to = target)

# --- Build full igraph from the pre-filtered edge list (using `graph_from_data_frame`) ---
g_full <- graph_from_data_frame(edges_df_for_igraph, directed = TRUE, vertices = nodes_tbl_cleaned$id)

# --- Get N-hop outward neighborhood (2-hop in this case) ---
# Use mode = "out" to get nodes influenced by Sailor Shift
ego_nodes_indices_out <- ego(graph = g_full, order = max_hops_for_context, nodes = sailor_id, mode = "out")[[1]]
connected_ids_outward <- names(ego_nodes_indices_out)

# --- Prepare Nodes for visNetwork (Outward) ---
nodes_for_outward_visnetwork <- nodes_tbl_cleaned %>%
  filter(id %in% connected_ids_outward) %>%
  mutate(
    label = name,
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      if_else(`Node Type` == "Song" & !is.na(release_date), paste0("<b>Release Date:</b> ", release_date, "<br>"), ""),
      if_else(!is.na(genre), paste0("<b>Genre:</b> ", genre, "<br>"), ""),
      if_else(!is.na(stage_name), paste0("<b>Stage Name:</b> ", stage_name, "<br>"), ""),
      if_else(!is.na(notable), paste0("<b>Notable:</b> ", notable, "<br>"), "")
    ),
    group = if_else(`Node Type` == "Song" & !is.na(genre), genre, `Node Type`),
    size = ifelse(id == sailor_id, 50, 15) # Sailor Shift node size set to 50
  ) %>%
  # Calculate node display color based on Node Type/Genre and Sailor Shift override
  mutate(
    base_color_from_map = all_node_type_colors[group],
    node_display_color = case_when(
      !is.na(base_color_from_map) ~ base_color_from_map,
      `Node Type` == "Song" & !is.na(genre) ~ all_node_type_colors["default_genre"],
      TRUE ~ all_node_type_colors["default"]
    ),
    node_display_color = ifelse(id == sailor_id, "gold", node_display_color) # Highlight Sailor Shift
  )


# --- Prepare Edges for visNetwork (Outward & AGGREGATED) ---
sub_edges_outward <- edges_df_for_igraph %>%
  filter(from %in% nodes_for_outward_visnetwork$id & to %in% nodes_for_outward_visnetwork$id) %>%
  filter(`Edge Type` %in% desired_edge_types_to_display) %>%
  # --- AGGREGATE EDGES HERE ---
  group_by(from, to) %>%
  summarise(
    # Concatenate all unique edge types into a single label
    aggregated_label = paste(sort(unique(`Edge Type`)), collapse = ", "),
    # For color, pick the color of the first edge type (you could define a custom rule)
    color = all_edge_type_colors[first(`Edge Type`)],
    arrows = "to",
    .groups = 'drop'
  ) %>%
  mutate(
    label = aggregated_label, # Use the combined label for display
    title = aggregated_label # Use the combined label for hover tooltip
  ) %>%
  # Ensure no NA colors if a type wasn't in `all_edge_type_colors`
  mutate(color = ifelse(is.na(color), all_edge_type_colors["default"], color))


# --- IMPORTANT: Check if nodes or edges are empty before plotting ---
if (nrow(nodes_for_outward_visnetwork) == 0) {
  message("No nodes found for the specified filters. Cannot create the network graph.")
} else if (nrow(sub_edges_outward) == 0) {
  message("No edges found for the specified filters between the selected nodes. The network graph will be empty or show only isolated nodes.")
} else {
  # --- Create the visNetwork plot ---
  graph_outward_context <- visNetwork(nodes = nodes_for_outward_visnetwork, edges = sub_edges_outward,
                                      main = paste0("Outward Links from '", target_name, "' (", max_hops_for_context, "-hop, Aggregated Edge Types)")) %>%
    visNodes(
      color = list(
        background = ~node_display_color,
        border = "black",
        highlight = list(background = "red", border = "darkred"),
        hover = list(background = "lightgray", border = "darkgray")
      ),
      shadow = TRUE,
      font = list(size = 12),
      shape = "dot"
    ) %>%
    visEdges(
      arrows = "to",
      label = ~label, # Use the aggregated label
      font = list(size = 10, align = "middle"),
      title = ~title, # Use aggregated label for hover
      color = list(color = ~color, highlight = ~color),
      smooth = list(enabled = TRUE, type = "continuous", roundness = 0.5), # Static smoothing
      width = 1
    ) %>%
    visOptions(
      highlightNearest = TRUE, # No specific degree, as per reference
      nodesIdSelection = list(enabled = TRUE, selected = sailor_id, useLabels = TRUE),
      selectedBy = "group"
    ) %>%
    # Define node groups and their colors explicitly for the legend (visGroups)
    # visGroups(groupname = "Song", color = all_node_type_colors["Song"]) %>%
    # visGroups(groupname = "Person", color = all_node_type_colors["Person"]) %>%
    # visGroups(groupname = "RecordLabel", color = all_node_type_colors["RecordLabel"]) %>%
    # visGroups(groupname = "Album", color = all_node_type_colors["Album"]) %>%
    # visGroups(groupname = "MusicalGroup", color = all_node_type_colors["MusicalGroup"]) %>%
    # Add any other groups that might be generated from genres if desired, e.g.,
    # visGroups(groupname = "Oceanus Folk", color = all_node_type_colors["Oceanus Folk"]) %>%

    # Legend (on the left)
    visLegend(
      main = "Node Types & Genres",
      useGroups = TRUE,
      position = "left",
      width = 0.15
    ) %>%
    # --- Edge Legend: Show original edge types, not aggregated labels ---
    visLegend(
      main = "Edge Types",
      addEdges = data.frame(
        color = all_edge_type_colors[desired_edge_types_to_display],
        label = desired_edge_types_to_display,
        font.align = "top"
      ),
      position = "right",
      width = 0.15
    ) %>%
    visInteraction(
      navigationButtons = TRUE,
      keyboard = TRUE
    ) %>%
    # Apply initial igraph layout (static)
    visIgraphLayout(layout = "layout_with_fr", randomSeed = 1234) %>%
    # Explicitly disable physics to make the graph static
    visPhysics(enabled = FALSE)

  # Display the network
  graph_outward_context

  # Optional: Save the network as an HTML file
  # visSave(graph_outward_context, file = paste0(target_name, "_outward_aggregated_", max_hops_for_context, "hop.html"))
}
```

improved version - previous one above only show linkage till a person

```{r}
# Libraries
library(dplyr)
library(jsonlite)
library(igraph)
library(visNetwork)
library(stringr)

# --- 1. Load your JSON data ---
kg <- fromJSON("data/MC1_graph.json")
nodes_tbl <- as_tibble(kg$nodes)
edges_tbl <- as_tibble(kg$links)

# --- Define Global Colors ---
all_node_type_colors <- c(
  "Person" = "orange",
  "MusicalGroup" = "purple",
  "Genre" = "lightgreen", # Keep if genre nodes are somehow introduced elsewhere
  "Song" = "lightblue",
  "Album" = "brown",
  "RecordLabel" = "darkred",
  "default" = "gray" # Fallback for any unmapped Node Types
)

all_edge_type_colors <- c(
  "PerformerOf" = "#FF5733", "ComposerOf" = "#33FF57", "ProducerOf" = "#3357FF",
  "LyricistOf" = "#FF33F5", "RecordedBy" = "#F5FF33", "InterpolatesFrom" = "#8A2BE2",
  "InStyleOf" = "#DAA520", "LyricalReferenceTo" = "#5F9EA0", "CoverOf" = "#DC143C",
  "DirectlySamples" = "#6A5ACD", "DistributedBy" = "#20B2AA", "MemberOf" = "#8B4513",
  "default" = "#CCCCCC" # Fallback for unlisted edge types
)

# --- Configuration ---
target_name <- "Sailor Shift"
graph_title <- paste0("Connections from '", target_name, "'s Songs to Related Songs and their Artistes (with MemberOf links and Inferred Artiste Genres)")

# --- Define specific edge types for each part of the path ---
artiste_to_song_types <- c("PerformerOf", "ComposerOf", "ProducerOf", "LyricistOf")
song_to_song_types <- c("InterpolatesFrom", "DirectlySamples", "InStyleOf", "CoverOf", "LyricalReferenceTo")

# --- IMPORTANT: Strict Node ID Cleaning (refined for robust uniqueness) ---
nodes_tbl_cleaned <- nodes_tbl %>%
  mutate(id = as.character(id)) %>% # Convert original ID to character first
  mutate(id = trimws(id)) %>%       # Trim whitespace from character IDs
  # Temporarily convert to numeric to filter out non-numeric IDs that might have slipped through
  mutate(temp_numeric_id = suppressWarnings(as.numeric(id))) %>% # suppressWarnings to avoid warnings for NAs
  filter(!is.na(temp_numeric_id)) %>% # Keep only IDs that successfully converted to numeric
  select(-temp_numeric_id) %>% # Remove the temporary column
  distinct(id, .keep_all = TRUE) %>% # Ensure uniqueness based on the cleaned ID
  mutate(`Node Type` = trimws(`Node Type`)) # Clean Node Type strings

# --- Get target node ID from the cleaned nodes table ---
sailor_node <- nodes_tbl_cleaned %>%
  filter(name == trimws(target_name)) # Trim target_name for robust matching

if (nrow(sailor_node) == 0) {
  stop(paste("No node named '", target_name, "' found in cleaned data. Ensure the name is correct and node ID is valid.", sep=""))
}
sailor_id <- as.character(sailor_node$id)


# --- IMPORTANT: Pre-filter edges to ensure valid source/target IDs ---
valid_node_ids <- nodes_tbl_cleaned$id

edges_df_for_igraph <- edges_tbl %>%
  select(source, target, `Edge Type`, key) %>%
  mutate(across(c(source, target), as.character)) %>%
  mutate(across(c(source, target), trimws)) %>% # Trim source/target IDs
  filter(source %in% valid_node_ids & target %in% valid_node_ids) %>%
  rename(from = source, to = target)


# --- NEW: Infer Genres for Person/MusicalGroup Nodes ---
genre_inference_edge_types <- c("PerformerOf", "ComposerOf", "ProducerOf", "LyricistOf", "RecordedBy")

artiste_song_genre_links <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% genre_inference_edge_types) %>%
  inner_join(nodes_tbl_cleaned %>% select(id, `Node Type`, genre),
             by = c("to" = "id")) %>%
  filter(`Node Type` == "Song") %>% # Ensure the target node is a Song
  select(artiste_id = from, song_genre = genre) %>%
  filter(!is.na(song_genre) & song_genre != "") # Only consider songs with a defined genre

inferred_genres_for_artistes <- artiste_song_genre_links %>%
  group_by(artiste_id) %>%
  summarise(
    inferred_genre = paste(sort(unique(song_genre)), collapse = ", "),
    .groups = 'drop'
  )


# --- Path Tracing Logic ---

# Step 1: Get Songs directly linked to Sailor Shift
sailor_to_song_edges <- edges_df_for_igraph %>%
  filter(from == sailor_id & `Edge Type` %in% artiste_to_song_types)

sailor_direct_song_ids <- unique(sailor_to_song_edges$to)

# Step 2: Get Songs related to Sailor Shift's direct songs
song_to_song_edges <- edges_df_for_igraph %>%
  filter(from %in% sailor_direct_song_ids & `Edge Type` %in% song_to_song_types)

related_song_ids <- unique(song_to_song_edges$to)

# Step 3: Get Artistes connected to these related songs
connected_artistes_edges <- edges_df_for_igraph %>%
  filter(to %in% related_song_ids & `Edge Type` %in% artiste_to_song_types)

connected_artiste_ids <- unique(connected_artistes_edges$from)

# --- Combine all relevant nodes for the visNetwork graph ---
# Include Sailor Shift, their direct songs, the related songs, and the connected artistes
all_relevant_node_ids <- unique(c(
  sailor_id,
  sailor_direct_song_ids,
  related_song_ids,
  connected_artiste_ids
))

nodes_for_visnetwork <- nodes_tbl_cleaned %>%
  filter(id %in% all_relevant_node_ids) %>%
  # Left join inferred genres to Person/MusicalGroup nodes
  left_join(inferred_genres_for_artistes, by = c("id" = "artiste_id")) %>%
  mutate(
    label = name,
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      if_else(`Node Type` == "Song" & !is.na(release_date), paste0("<b>Release Date:</b> ", release_date, "<br>"), ""),
      if_else(!is.na(genre), paste0("<b>Genre (Node):</b> ", genre, "<br>"), ""), # Original node genre if exists
      if_else(!is.na(inferred_genre), paste0("<b>Genre (Inferred):</b> ", inferred_genre, "<br>"), ""), # New inferred genre
      if_else(!is.na(stage_name), paste0("<b>Stage Name:</b> ", stage_name, "<br>"), ""),
      if_else(!is.na(notable), paste0("<b>Notable:</b> ", notable, "<br>"), "")
    ),
    group = `Node Type`, # Group by Node Type for legend
    size = ifelse(id == sailor_id, 50, 20) # Highlight Sailor Shift with larger size
  ) %>%
  # Calculate node display color based on Node Type and Sailor Shift override
  mutate(
    base_color_from_map = all_node_type_colors[group],
    node_display_color = ifelse(is.na(base_color_from_map), all_node_type_colors["default"], base_color_from_map),
    node_display_color = ifelse(id == sailor_id, "gold", node_display_color) # Highlight Sailor Shift
  )


# --- Prepare Edges for visNetwork: Combine aggregated path edges with MemberOf edges ---

# 1. Combine all specific path edges before aggregation
all_traced_path_edges <- bind_rows(
  sailor_to_song_edges,
  song_to_song_edges,
  connected_artistes_edges
) %>%
  # Filter to ensure they only connect nodes that are part of our final selection
  filter(from %in% nodes_for_visnetwork$id & to %in% nodes_for_visnetwork$id)

# 2. Aggregate the main path edges (Artiste-Song-Song-Artiste)
aggregated_path_edges <- all_traced_path_edges %>%
  group_by(from, to) %>%
  summarise(
    aggregated_label = paste(sort(unique(`Edge Type`)), collapse = ", "),
    color = all_edge_type_colors[first(`Edge Type`)],
    arrows = "to",
    .groups = 'drop'
  ) %>%
  mutate(
    label = aggregated_label, # Use the combined label for display in the graph
    title = aggregated_label # Use the combined label for hover tooltip in the graph
  ) %>%
  mutate(color = ifelse(is.na(color), all_edge_type_colors["default"], color))

# 3. Find MemberOf edges between relevant Person and MusicalGroup nodes within the current graph
relevant_person_group_ids <- nodes_for_visnetwork %>%
  filter(`Node Type` %in% c("Person", "MusicalGroup")) %>%
  pull(id)

member_of_edges_prepared <- edges_df_for_igraph %>%
  filter(`Edge Type` == "MemberOf") %>%
  # Ensure both ends of the MemberOf edge are already in our selected nodes
  filter(from %in% relevant_person_group_ids & to %in% relevant_person_group_ids) %>%
  mutate(
    label = `Edge Type`, # Label is simply "MemberOf"
    title = `Edge Type`, # Title is simply "MemberOf"
    color = all_edge_type_colors[`Edge Type`],
    arrows = "to" # MemberOf is typically directed from Person to Group
  ) %>%
  mutate(color = ifelse(is.na(color), all_edge_type_colors["default"], color)) %>%
  # Select the same columns as aggregated_path_edges for binding
  select(from, to, label, title, color, arrows)

# 4. Finally, combine the aggregated path edges and the prepared MemberOf edges
edges_for_visnetwork <- bind_rows(
  aggregated_path_edges,
  member_of_edges_prepared
) %>%
  # Remove any truly identical duplicate rows that might occur after binding
  distinct(from, to, label, .keep_all = TRUE)


# --- Prepare groups for visGroups (robust legend) ---
actual_node_groups <- unique(nodes_for_visnetwork$group)
actual_node_groups <- actual_node_groups[!is.na(actual_node_groups) & actual_node_groups != ""]

if (length(actual_node_groups) == 0) {
  message("Warning: No valid node groups found for visGroups. Legend might not display correctly.")
  groups_for_visnetwork <- data.frame(id = character(0), color = character(0), label = character(0), stringsAsFactors = FALSE)
} else {
  groups_for_visnetwork <- data.frame(
    id = actual_node_groups,
    color = as.character(sapply(actual_node_groups, function(g) {
      if (!is.na(all_node_type_colors[g])) {
        return(all_node_type_colors[g])
      } else {
        return(all_node_type_colors["default"])
      }
    })),
    label = actual_node_groups,
    stringsAsFactors = FALSE
  )
}


# --- IMPORTANT: Check if nodes or edges are empty before plotting ---
if (nrow(nodes_for_visnetwork) == 0) {
  message("No nodes found for the specified path. Cannot create the network graph.")
} else if (nrow(edges_for_visnetwork) == 0) {
  message("No edges found for the specified path between the selected nodes. The network graph will be empty or show only isolated nodes.")
} else {
  # --- Prepare data for the Edge Legend ---
  legend_edge_types_to_display <- names(all_edge_type_colors)[names(all_edge_type_colors) != "default"]

  # --- Create the visNetwork plot ---
  graph_specific_path <- visNetwork(nodes = nodes_for_visnetwork, edges = edges_for_visnetwork,
                                    main = graph_title) %>%
    visNodes(
      color = list(
        background = ~node_display_color,
        border = "black",
        highlight = list(background = "red", border = "darkred"),
        hover = list(background = "lightgray", border = "darkgray")
      ),
      shadow = TRUE,
      font = list(size = 12),
      shape = "dot"
    ) %>%
    visEdges(
      arrows = "to",
      label = ~label, # Use the aggregated label for edges in the graph itself
      font = list(size = 10, align = "middle"),
      title = ~title, # Use aggregated label for hover
      color = list(color = ~color, highlight = ~color),
      smooth = list(enabled = TRUE, type = "continuous", roundness = 0.5), # Static smoothing
      width = 1
    ) %>%
    visOptions(
      highlightNearest = list(enabled = TRUE, degree = 2), #Make it such that it highlights till 2levels of links
      nodesIdSelection = list(enabled = TRUE, selected = sailor_id, useLabels = TRUE), # Highlight Sailor Shift on load
      selectedBy = "group" # Allows filtering by Node Type
    ) %>%
    # Apply visGroups for each group found in our prepared data frame
    {
      temp_vis_object <- .
      for (i in 1:nrow(groups_for_visnetwork)) {
        group_id <- groups_for_visnetwork$id[i]
        group_color <- groups_for_visnetwork$color[i]
        temp_vis_object <- temp_vis_object %>%
          visGroups(groupname = group_id, color = group_color)
      }
      temp_vis_object
    } %>% # End of the curly braces block
    visLegend(
      main = "Node Types",
      useGroups = TRUE,
      position = "left",
      width = 0.15
    ) %>%
    # --- Edge Legend: Show original edge types and their colors ---
    visLegend(
      main = "Edge Types",
      addEdges = data.frame(
        color = all_edge_type_colors[legend_edge_types_to_display],
        label = legend_edge_types_to_display,
        font.align = "top"
      ),
      position = "right",
      width = 0.15
    ) %>%
    visInteraction(
      navigationButtons = TRUE,
      keyboard = TRUE
    ) %>%
    visIgraphLayout(layout = "layout_with_fr", randomSeed = 1234) %>%
    visPhysics(enabled = FALSE) # Explicitly disable physics to make the graph static

  # Display the network
  graph_specific_path

  # Optional: Save the network as an HTML file
  # visSave(graph_specific_path, file = paste0(target_name, "_song_to_related_song_path.html"))
}
```

## Inward link influenced by

```{r}
# Libraries
library(dplyr)
library(jsonlite)
library(igraph)
library(visNetwork)
library(viridisLite) # For viridis palette (though not directly used, kept for consistency if planned)
library(stringr)

# --- 1. Load your JSON data ---
# Assuming 'MC1_graph.json' is in your working directory
kg <- fromJSON("data/MC1_graph.json")
nodes_tbl <- as_tibble(kg$nodes)
edges_tbl <- as_tibble(kg$links)

# all_node_type_colors <- c(
#   "Song" = "lightblue",
#   "Person" = "orange",
#   "MusicalGroup" = "purple",
#   "RecordLabel" = "lightgreen",
#   "Album" = "brown",
#   "Oceanus Folk" = "#FFD700",
#   "Rock" = "red",       # <-- Add your discovered genres here
#   "Pop" = "pink",       # <-- with distinct colors
#   "Hip Hop" = "green",  # <--
#   "default_genre" = "#7FFF00",
#   "default" = "gray"
# )

# --- Configuration ---
target_name <- "Sailor Shift"
max_hops_for_context <- 2 # For 2-hop neighborhood

# --- NEW: Define which edge types to display and include in the legend ---
# Only these specific edge types will be considered for aggregation
desired_edge_types_to_display <- c(
  "InterpolatesFrom",
  "DirectlySamples",
  "InStyleOf",
  "CoverOf",
  "LyricalReferenceTo",
  "ProducerOf",
  "ComposerOf",
  "PerformerOf",
  "LyricistOf",
  "MemberOf"
)

# --- IMPORTANT: Strict Node ID Cleaning ---
nodes_tbl_cleaned <- nodes_tbl %>%
  mutate(
    temp_numeric_id = as.numeric(as.character(id))
  ) %>%
  filter(!is.na(temp_numeric_id)) %>%
  mutate(id = as.character(temp_numeric_id)) %>%
  select(-temp_numeric_id) %>%
  distinct(id, .keep_all = TRUE) # Ensure unique IDs after cleaning

# --- Get target node ID from the cleaned nodes table ---
sailor_node <- nodes_tbl_cleaned %>% filter(name == target_name)
if (nrow(sailor_node) == 0) stop(paste("No node named '", target_name, "' found in cleaned data.", sep=""))
sailor_id <- as.character(sailor_node$id)

# --- IMPORTANT: Pre-filter edges to ensure valid source/target IDs ---
valid_node_ids <- nodes_tbl_cleaned$id

edges_df_for_igraph <- edges_tbl %>%
  select(source, target, `Edge Type`, key) %>%
  filter(source %in% valid_node_ids & target %in% valid_node_ids) %>%
  mutate(across(c(source, target), as.character)) %>%
  rename(from = source, to = target)

# --- Build full igraph from the pre-filtered edge list (using `graph_from_data_frame`) ---
g_full <- graph_from_data_frame(edges_df_for_igraph, directed = TRUE, vertices = nodes_tbl_cleaned$id)

# --- Get N-hop inward neighborhood (2-hop in this case) ---
# Use mode = "in" to get nodes influencing Sailor Shift
ego_nodes_indices_in <- ego(graph = g_full, order = max_hops_for_context, nodes = sailor_id, mode = "in")[[1]]
connected_ids_inward <- names(ego_nodes_indices_in)

# --- Prepare Nodes for visNetwork (Inward) ---
nodes_for_inward_visnetwork <- nodes_tbl_cleaned %>%
  filter(id %in% connected_ids_inward) %>%
  mutate(
    label = name,
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      if_else(`Node Type` == "Song" & !is.na(release_date), paste0("<b>Release Date:</b> ", release_date, "<br>"), ""),
      if_else(!is.na(genre), paste0("<b>Genre:</b> ", genre, "<br>"), ""),
      if_else(!is.na(stage_name), paste0("<b>Stage Name:</b> ", stage_name, "<br>"), ""),
      if_else(!is.na(notable), paste0("<b>Notable:</b> ", notable, "<br>"), "")
    ),
    group = if_else(`Node Type` == "Song" & !is.na(genre), genre, `Node Type`),
    size = ifelse(id == sailor_id, 50, 15) # Sailor Shift node size set to 50
  ) %>%
  # Calculate node display color based on Node Type/Genre and Sailor Shift override
  mutate(
    base_color_from_map = all_node_type_colors[group],
    node_display_color = case_when(
      !is.na(base_color_from_map) ~ base_color_from_map,
      `Node Type` == "Song" & !is.na(genre) ~ all_node_type_colors["default_genre"],
      TRUE ~ all_node_type_colors["default"]
    ),
    node_display_color = ifelse(id == sailor_id, "gold", node_display_color) # Highlight Sailor Shift
  )


# --- Prepare Edges for visNetwork (Inward & AGGREGATED) ---
sub_edges_inward <- edges_df_for_igraph %>%
  filter(from %in% nodes_for_inward_visnetwork$id & to %in% nodes_for_inward_visnetwork$id) %>%
  filter(`Edge Type` %in% desired_edge_types_to_display) %>%
  # --- AGGREGATE EDGES HERE ---
  group_by(from, to) %>%
  summarise(
    # Concatenate all unique edge types into a single label
    aggregated_label = paste(sort(unique(`Edge Type`)), collapse = ", "),
    # For color, pick the color of the first edge type (you could define a custom rule)
    color = all_edge_type_colors[first(`Edge Type`)],
    arrows = "to",
    .groups = 'drop'
  ) %>%
  mutate(
    label = aggregated_label, # Use the combined label for display
    title = aggregated_label # Use the combined label for hover tooltip
  ) %>%
  # Ensure no NA colors if a type wasn't in `all_edge_type_colors`
  mutate(color = ifelse(is.na(color), all_edge_type_colors["default"], color))


# --- IMPORTANT: Check if nodes or edges are empty before plotting ---
if (nrow(nodes_for_inward_visnetwork) == 0) {
  message("No nodes found for the specified filters. Cannot create the network graph.")
} else if (nrow(sub_edges_inward) == 0) {
  message("No edges found for the specified filters between the selected nodes. The network graph will be empty or show only isolated nodes.")
} else {
  # --- Create the visNetwork plot ---
  graph_inward_context <- visNetwork(nodes = nodes_for_inward_visnetwork, edges = sub_edges_inward,
                                     main = paste0("Inward Links Towards '", target_name, "' (", max_hops_for_context, "-hop, Aggregated Edge Types)")) %>%
    visNodes(
      color = list(
        background = ~node_display_color,
        border = "black",
        highlight = list(background = "red", border = "darkred"),
        hover = list(background = "lightgray", border = "darkgray")
      ),
      shadow = TRUE,
      font = list(size = 12),
      shape = "dot"
    ) %>%
    visEdges(
      arrows = "to",
      label = ~label, # Use the aggregated label
      font = list(size = 10, align = "middle"),
      title = ~title, # Use aggregated label for hover
      color = list(color = ~color, highlight = ~color),
      smooth = list(enabled = TRUE, type = "continuous", roundness = 0.5), # Static smoothing
      width = 1
    ) %>%
    visOptions(
      highlightNearest = TRUE, # No specific degree, as per reference
      nodesIdSelection = list(enabled = TRUE, selected = sailor_id, useLabels = TRUE),
      selectedBy = "group"
    ) %>%
    # Define node groups and their colors explicitly for the legend (visGroups)
    # visGroups(groupname = "Song", color = all_node_type_colors["Song"]) %>%
    # visGroups(groupname = "Person", color = all_node_type_colors["Person"]) %>%
    # visGroups(groupname = "RecordLabel", color = all_node_type_colors["RecordLabel"]) %>%
    # visGroups(groupname = "Album", color = all_node_type_colors["Album"]) %>%
    # visGroups(groupname = "MusicalGroup", color = all_node_type_colors["MusicalGroup"]) %>%
    # Add any other groups that might be generated from genres if desired, e.g.,
    # visGroups(groupname = "Oceanus Folk", color = all_node_type_colors["Oceanus Folk"]) %>%

    # Legend (on the left)
    visLegend(
      main = "Node Types & Genres",
      useGroups = TRUE,
      position = "left",
      width = 0.15
    ) %>%
    # --- Edge Legend: Show original edge types, not aggregated labels ---
    visLegend(
      main = "Edge Types",
      addEdges = data.frame(
        color = all_edge_type_colors[desired_edge_types_to_display],
        label = desired_edge_types_to_display,
        font.align = "top"
      ),
      position = "right",
      width = 0.15
    ) %>%
    visInteraction(
      navigationButtons = TRUE,
      keyboard = TRUE
    ) %>%
    # Apply initial igraph layout (static)
    visIgraphLayout(layout = "layout_with_fr", randomSeed = 1234) %>%
    # Explicitly disable physics to make the graph static
    visPhysics(enabled = FALSE)

  # Display the network
  graph_inward_context

  # Optional: Save the network as an HTML file
  # visSave(graph_inward_context, file = paste0(target_name, "_inward_aggregated_", max_hops_for_context, "hop.html"))
}
```

```{r}
# Libraries
library(dplyr)
library(jsonlite)
library(igraph)
library(visNetwork)
library(stringr)

# --- 1. Load your JSON data ---
kg <- fromJSON("data/MC1_graph.json")
nodes_tbl <- as_tibble(kg$nodes)
edges_tbl <- as_tibble(kg$links)

# --- Define Global Colors ---
all_node_type_colors <- c(
  "Person" = "orange",
  "MusicalGroup" = "purple",
  "Genre" = "lightgreen",
  "Song" = "lightblue",
  "Album" = "brown",
  "RecordLabel" = "darkred",
  "default" = "gray" # Fallback for any unmapped Node Types
)

all_edge_type_colors <- c(
  "PerformerOf" = "#FF5733", "ComposerOf" = "#33FF57", "ProducerOf" = "#3357FF",
  "LyricistOf" = "#FF33F5", "RecordedBy" = "#F5FF33", "InterpolatesFrom" = "#8A2BE2",
  "InStyleOf" = "#DAA520", "LyricalReferenceTo" = "#5F9EA0", "CoverOf" = "#DC143C",
  "DirectlySamples" = "#6A5ACD", "DistributedBy" = "#20B2AA", "MemberOf" = "#8B4513",
  "default" = "#CCCCCC" # Fallback for unlisted edge types
)

# --- Configuration ---
target_name <- "Sailor Shift"
max_hops_for_context <- 2 # For 2-hop neighborhood
graph_title <- paste0("Inward Connections Towards '", target_name, "' (", max_hops_for_context, "-hop, with MemberOf links and Inferred Artiste Genres)")

# --- IMPORTANT: Strict Node ID Cleaning (refined for robust uniqueness) ---
nodes_tbl_cleaned <- nodes_tbl %>%
  mutate(id = as.character(id)) %>% # Convert original ID to character first
  mutate(id = trimws(id)) %>%       # Trim whitespace from character IDs
  # Temporarily convert to numeric to filter out non-numeric IDs that might have slipped through
  mutate(temp_numeric_id = suppressWarnings(as.numeric(id))) %>% # suppressWarnings to avoid warnings for NAs
  filter(!is.na(temp_numeric_id)) %>% # Keep only IDs that successfully converted to numeric
  mutate(id = as.character(temp_numeric_id)) %>% # Convert numeric back to character for consistent IDs
  select(-temp_numeric_id) %>% # Remove the temporary column
  distinct(id, .keep_all = TRUE) %>% # Ensure unique IDs based on the cleaned ID
  mutate(`Node Type` = trimws(`Node Type`)) # Clean Node Type strings

# --- Get target node ID from the cleaned nodes table ---
sailor_node <- nodes_tbl_cleaned %>%
  filter(name == trimws(target_name)) # Trim target_name for robust matching

if (nrow(sailor_node) == 0) {
  stop(paste("No node named '", target_name, "' found in cleaned data. Ensure the name is correct and node ID is valid.", sep=""))
}
sailor_id <- as.character(sailor_node$id)

# --- IMPORTANT: Pre-filter edges to ensure valid source/target IDs ---
valid_node_ids <- nodes_tbl_cleaned$id

edges_df_for_igraph <- edges_tbl %>%
  select(source, target, `Edge Type`, key) %>%
  mutate(across(c(source, target), as.character)) %>%
  mutate(across(c(source, target), trimws)) %>% # Trim source/target IDs
  filter(source %in% valid_node_ids & target %in% valid_node_ids) %>%
  rename(from = source, to = target)

# --- DIAGNOSTIC CHECK: Ensure no duplicate vertex IDs before building igraph ---
if (any(duplicated(nodes_tbl_cleaned$id))) {
  duplicate_ids <- nodes_tbl_cleaned$id[duplicated(nodes_tbl_cleaned$id)]
  stop(paste("FATAL ERROR: Duplicate node IDs found in 'nodes_tbl_cleaned$id' even after cleaning. Duplicates: ",
             paste(unique(duplicate_ids), collapse = ", "),
             ". Please inspect your original 'MC1_graph.json' data for these IDs.", sep=""))
}

# --- Build full igraph from the pre-filtered edge list (using `graph_from_data_frame`) ---
g_full <- graph_from_data_frame(edges_df_for_igraph, directed = TRUE, vertices = nodes_tbl_cleaned$id)

# --- Get N-hop inward neighborhood (2-hop in this case) ---
ego_nodes_indices_in <- ego(graph = g_full, order = max_hops_for_context, nodes = sailor_id, mode = "in")[[1]]
connected_ids_inward <- names(ego_nodes_indices_in)

# --- NEW: Infer Genres for Person/MusicalGroup Nodes ---
genre_inference_edge_types <- c("PerformerOf", "ComposerOf", "ProducerOf", "LyricistOf", "RecordedBy")

artiste_song_genre_links <- edges_df_for_igraph %>%
  filter(`Edge Type` %in% genre_inference_edge_types) %>%
  inner_join(nodes_tbl_cleaned %>% select(id, `Node Type`, genre),
             by = c("to" = "id")) %>%
  filter(`Node Type` == "Song") %>% # Ensure the target node is a Song
  select(artiste_id = from, song_genre = genre) %>%
  filter(!is.na(song_genre) & song_genre != "") # Only consider songs with a defined genre

inferred_genres_for_artistes <- artiste_song_genre_links %>%
  group_by(artiste_id) %>%
  summarise(
    inferred_genre = paste(sort(unique(song_genre)), collapse = ", "),
    .groups = 'drop'
  )

# --- Prepare Nodes for visNetwork (Inward) ---
nodes_for_inward_visnetwork <- nodes_tbl_cleaned %>%
  filter(id %in% connected_ids_inward) %>%
  # Left join inferred genres to Person/MusicalGroup nodes
  left_join(inferred_genres_for_artistes, by = c("id" = "artiste_id")) %>%
  mutate(
    label = name,
    title = paste0(
      "<b>Name:</b> ", name, "<br>",
      "<b>Node Type:</b> ", `Node Type`, "<br>",
      if_else(`Node Type` == "Song" & !is.na(release_date), paste0("<b>Release Date:</b> ", release_date, "<br>"), ""),
      if_else(!is.na(genre), paste0("<b>Genre (Node):</b> ", genre, "<br>"), ""), # Original node genre if exists
      if_else(!is.na(inferred_genre), paste0("<b>Genre (Inferred):</b> ", inferred_genre, "<br>"), ""), # New inferred genre
      if_else(!is.na(stage_name), paste0("<b>Stage Name:</b> ", stage_name, "<br>"), ""),
      if_else(!is.na(notable), paste0("<b>Notable:</b> ", notable, "<br>"), "")
    ),
    group = `Node Type`, # Still group by Node Type for main legend
    size = ifelse(id == sailor_id, 50, 20) # Highlight Sailor Shift with larger size
  ) %>%
  # Calculate node display color based on Node Type and Sailor Shift override
  mutate(
    base_color_from_map = all_node_type_colors[group],
    node_display_color = ifelse(is.na(base_color_from_map), all_node_type_colors["default"], base_color_from_map),
    node_display_color = ifelse(id == sailor_id, "gold", node_display_color) # Highlight Sailor Shift
  )


# --- Prepare Edges for visNetwork: Combine aggregated inward edges with MemberOf edges ---

# 1. Filter original edges to include only those within the inward neighborhood
# and those desired for display (excluding MemberOf for initial aggregation)
edges_within_inward_scope <- edges_df_for_igraph %>%
  filter(from %in% nodes_for_inward_visnetwork$id & to %in% nodes_for_inward_visnetwork$id) %>%
  filter(`Edge Type` != "MemberOf") # Exclude MemberOf from aggregation for now

# 2. Aggregate these inward edges
aggregated_inward_edges <- edges_within_inward_scope %>%
  group_by(from, to) %>%
  summarise(
    aggregated_label = paste(sort(unique(`Edge Type`)), collapse = ", "),
    color = all_edge_type_colors[first(`Edge Type`)],
    arrows = "to",
    .groups = 'drop'
  ) %>%
  mutate(
    label = aggregated_label,
    title = aggregated_label
  ) %>%
  mutate(color = ifelse(is.na(color), all_edge_type_colors["default"], color))


# 3. Find MemberOf edges between relevant Person and MusicalGroup nodes within the current graph
relevant_person_group_ids_inward <- nodes_for_inward_visnetwork %>%
  filter(`Node Type` %in% c("Person", "MusicalGroup")) %>%
  pull(id)

member_of_edges_inward_prepared <- edges_df_for_igraph %>%
  filter(`Edge Type` == "MemberOf") %>%
  # Ensure both ends of the MemberOf edge are already in our selected inward nodes
  filter(from %in% relevant_person_group_ids_inward & to %in% relevant_person_group_ids_inward) %>%
  mutate(
    label = `Edge Type`, # Label is simply "MemberOf"
    title = `Edge Type`, # Title is simply "MemberOf"
    color = all_edge_type_colors[`Edge Type`],
    arrows = "to" # MemberOf is typically directed from Person to Group
  ) %>%
  mutate(color = ifelse(is.na(color), all_edge_type_colors["default"], color)) %>%
  # Select the same columns as aggregated_inward_edges for binding
  select(from, to, label, title, color, arrows)

# 4. Finally, combine the aggregated inward edges and the prepared MemberOf edges
edges_for_inward_visnetwork <- bind_rows(
  aggregated_inward_edges,
  member_of_edges_inward_prepared
) %>%
  # Remove any truly identical duplicate rows that might occur after binding
  distinct(from, to, label, .keep_all = TRUE)


# --- Prepare groups for visGroups (robust legend) ---
actual_node_groups_inward <- unique(nodes_for_inward_visnetwork$group)
actual_node_groups_inward <- actual_node_groups_inward[!is.na(actual_node_groups_inward) & actual_node_groups_inward != ""]

if (length(actual_node_groups_inward) == 0) {
  message("Warning: No valid node groups found for visGroups. Legend might not display correctly.")
  groups_for_visnetwork_inward <- data.frame(id = character(0), color = character(0), label = character(0), stringsAsFactors = FALSE)
} else {
  groups_for_visnetwork_inward <- data.frame(
    id = actual_node_groups_inward,
    color = as.character(sapply(actual_node_groups_inward, function(g) {
      if (!is.na(all_node_type_colors[g])) {
        return(all_node_type_colors[g])
      } else {
        return(all_node_type_colors["default"])
      }
    })),
    label = actual_node_groups_inward,
    stringsAsFactors = FALSE
  )
}

# --- IMPORTANT: Check if nodes or edges are empty before plotting ---
if (nrow(nodes_for_inward_visnetwork) == 0) {
  message("No nodes found for the specified filters. Cannot create the network graph.")
} else if (nrow(edges_for_inward_visnetwork) == 0) {
  message("No edges found for the specified filters between the selected nodes. The network graph will be empty or show only isolated nodes.")
} else {
  # --- Prepare data for the Edge Legend ---
  # Get all defined edge types from your color mapping, excluding 'default'
  legend_edge_types_to_display <- names(all_edge_type_colors)[names(all_edge_type_colors) != "default"]

  # --- Create the visNetwork plot ---
  graph_inward_context <- visNetwork(nodes = nodes_for_inward_visnetwork, edges = edges_for_inward_visnetwork,
                                     main = graph_title) %>%
    visNodes(
      color = list(
        background = ~node_display_color,
        border = "black",
        highlight = list(background = "red", border = "darkred"),
        hover = list(background = "lightgray", border = "darkgray")
      ),
      shadow = TRUE,
      font = list(size = 12),
      shape = "dot"
    ) %>%
    visEdges(
      arrows = "to", # Arrows pointing TO the target node in this inward graph
      label = ~label, # Use the aggregated label or "MemberOf"
      font = list(size = 10, align = "middle"),
      title = ~title, # Use aggregated label or "MemberOf" for hover
      color = list(color = ~color, highlight = ~color),
      smooth = list(enabled = TRUE, type = "continuous", roundness = 0.5), # Static smoothing
      width = 1
    ) %>%
    visOptions(
      highlightNearest = list(enabled = TRUE, degree = 1), #1 degree of connection is enough for this
      nodesIdSelection = list(enabled = TRUE, selected = sailor_id, useLabels = TRUE),
      selectedBy = "group"
    ) %>%
    # Apply visGroups for each group found in our prepared data frame
    {
      temp_vis_object <- .
      for (i in 1:nrow(groups_for_visnetwork_inward)) {
        group_id <- groups_for_visnetwork_inward$id[i]
        group_color <- groups_for_visnetwork_inward$color[i]
        temp_vis_object <- temp_vis_object %>%
          visGroups(groupname = group_id, color = group_color)
      }
      temp_vis_object
    } %>% # End of the curly braces block
    visLegend(
      main = "Node Types",
      useGroups = TRUE,
      position = "left",
      width = 0.15
    ) %>%
    # --- Edge Legend: Show original edge types and their colors ---
    visLegend(
      main = "Edge Types",
      addEdges = data.frame(
        color = all_edge_type_colors[legend_edge_types_to_display],
        label = legend_edge_types_to_display,
        font.align = "top"
      ),
      position = "right",
      width = 0.15
    ) %>%
    visInteraction(
      navigationButtons = TRUE,
      keyboard = TRUE
    ) %>%
    visIgraphLayout(layout = "layout_with_fr", randomSeed = 1234) %>%
    visPhysics(enabled = FALSE) # Explicitly disable physics to make the graph static

  # Display the network
  graph_inward_context

  # Optional: Save the network as an HTML file
  # visSave(graph_inward_context, file = paste0(target_name, "_inward_aggregated_", max_hops_for_context, "hop.html"))
}
```

# Sailor Shift TimeLine

## Timeline Data Prep
```{r}
# Install and load necessary packages
library(jsonlite)
library(dplyr)
library(ggplot2)
library(lubridate)
library(stringr)

#| fig-width: 12
#| fig-height: 8

# --- 1. Load your JSON data ---
# Ensure 'MC1_graph.json' is in the same directory as your R script
tryCatch({
  kg <- fromJSON('data/MC1_graph.json')
}, error = function(e) {
  stop("Error: 'MC1_graph.json' not found. Please ensure the file is in the same directory as this R script.\n", e$message)
})

nodes_tbl <- as_tibble(kg$nodes)
edges_tbl <- as_tibble(kg$links)

# --- Configuration ---
target_name <- "Sailor Shift"

# --- Strict Node ID Cleaning ---
nodes_tbl_cleaned <- nodes_tbl %>%
  mutate(id = as.character(id)) %>% # Convert original ID to character first
  mutate(id = trimws(id)) %>%       # Trim whitespace from character IDs
  # Temporarily convert to numeric to filter out non-numeric IDs that might have slipped through
  mutate(temp_numeric_id = suppressWarnings(as.numeric(id))) %>%
  filter(!is.na(temp_numeric_id)) %>% # Keep only IDs that successfully converted to numeric
  mutate(id = as.character(temp_numeric_id)) %>% # Convert numeric back to character for consistent IDs
  select(-temp_numeric_id) %>% # Remove the temporary column
  distinct(id, .keep_all = TRUE) # Ensure unique IDs based on the cleaned ID

# Clean Node Type strings (if column exists)
if ("Node Type" %in% colnames(nodes_tbl_cleaned)) {
  nodes_tbl_cleaned <- nodes_tbl_cleaned %>%
    mutate(`Node Type` = trimws(`Node Type`))
}

# --- Get target node ID for 'Sailor Shift' ---
sailor_node <- nodes_tbl_cleaned %>%
  filter(name == trimws(target_name))

if (nrow(sailor_node) == 0) {
  stop(paste("No node named '", target_name, "' found in cleaned data. Ensure the name is correct and node ID is valid.", sep=""))
}
sailor_id <- as.character(sailor_node$id)

# --- Prepare edges for igraph (using original IDs) ---
valid_node_ids <- nodes_tbl_cleaned$id

edges_df_for_igraph <- edges_tbl %>%
  select(source, target, `Edge Type`, key) %>%
  mutate(across(c(source, target), as.character)) %>%
  mutate(across(c(source, target), trimws)) %>% # Trim source/target IDs
  filter(source %in% valid_node_ids & target %in% valid_node_ids) %>%
  rename(from = source, to = target)

# --- Identify relevant songs and albums for Sailor Shift's timeline ---
# We'll consider nodes directly connected to Sailor Shift (both from and to)
relevant_connected_ids <- unique(c(
  edges_df_for_igraph %>% filter(from == sailor_id) %>% pull(to),
  edges_df_for_igraph %>% filter(to == sailor_id) %>% pull(from)
))

# Filter nodes for songs and albums that are relevant and have a release_date
timeline_nodes <- nodes_tbl_cleaned %>%
  filter(id %in% relevant_connected_ids & `Node Type` %in% c("Song", "Album")) %>%
  select(id, name, `Node Type`, release_date) %>%
  # --- FIX: Handling release_date as just a year ---
  # Filter out non-numeric or empty release_date entries that are not 4 digits
  filter(!is.na(release_date) & str_detect(as.character(release_date), "^\\d{4}$")) %>%
  # Convert year string to a Date object (e.g., "2040" -> "2040-01-01")
  mutate(release_date = lubridate::ymd(paste0(release_date, "-01-01"))) %>%
  # Ensure only valid dates remain after conversion (in case paste0 creates invalid dates)
  filter(!is.na(release_date)) %>%
  distinct(id, .keep_all = TRUE) # Ensure unique entries

# If no relevant nodes found after parsing, stop
if (nrow(timeline_nodes) == 0) {
  stop("No relevant songs or albums with valid release dates found for Sailor Shift to create a timeline after parsing years.")
}

# --- Simulate 'written_date' and 'notoriety_date' ---
set.seed(42) # For reproducibility

timeline_data <- timeline_nodes %>%
  mutate(written_date = as.Date(NA), # Initialize with NA Date
         notoriety_date = as.Date(NA))

# Simulate written_date for 30% of entries
num_to_simulate_written <- floor(nrow(timeline_data) * 0.3)
if (num_to_simulate_written > 0) {
  written_indices <- sample(1:nrow(timeline_data), num_to_simulate_written, replace = FALSE)
  for (i in written_indices) {
    release_dt <- timeline_data$release_date[i]
    if (!is.na(release_dt)) {
      # Written date 30-365 days before release
      days_before <- sample(30:365, 1)
      timeline_data$written_date[i] <- release_dt - days(days_before)
    }
  }
}

# Simulate notoriety_date for 20% of remaining entries
remaining_indices <- setdiff(1:nrow(timeline_data), written_indices)
num_to_simulate_notoriety <- floor(length(remaining_indices) * 0.2)
if (num_to_simulate_notoriety > 0) {
  notoriety_indices <- sample(remaining_indices, num_to_simulate_notoriety, replace = FALSE)
  for (i in notoriety_indices) {
    release_dt <- timeline_data$release_date[i]
    if (!is.na(release_dt)) {
      # Notoriety date 30-365 days after release
      days_after <- sample(30:365, 1)
      timeline_data$notoriety_date[i] <- release_dt + days(days_after)
    }
  }
}

# Create event_description
timeline_data <- timeline_data %>%
  mutate(event_description = paste0(name, " (", `Node Type`, ")"))

# --- Create the timeline plot ---
ggplot(timeline_data, aes(y = 0)) + # Y-axis position for points

  # Plot release events as points
  geom_point(aes(x = release_date,
                 shape = ifelse(!is.na(notoriety_date), "Notoriety Event", "Release Event")),
             size = 4, color = "darkblue") +

  # Add vertical lines for written dates
  geom_segment(aes(x = written_date, xend = written_date,
                   y = 0, yend = 0.2), # Line goes upwards for text
               color = "darkgreen", linetype = "dashed", size = 0.5, na.rm = TRUE) +

  # Add vertical lines for notoriety dates
  geom_segment(aes(x = notoriety_date, xend = notoriety_date,
                   y = 0, yend = -0.2), # Line goes downwards for notoriety indicator
               color = "red", linetype = "dotted", size = 0.5, na.rm = TRUE) +

  # Add text labels for events
  geom_text(aes(x = release_date, label = event_description, y = 0.05), # Position slightly above the point
            vjust = 0, hjust = 0.5, size = 3, angle = 90, check_overlap = TRUE) +

  # Add text labels for written dates
  geom_text(aes(x = written_date, label = paste0("Written: ", format(written_date, "%Y-%m-%d")), y = 0.2),
            vjust = 0, hjust = 0.5, size = 2.5, angle = 90, color = "darkgreen", na.rm = TRUE, check_overlap = TRUE) +

  # Add text labels for notoriety dates
  geom_text(aes(x = notoriety_date, label = paste0("Notoriety: ", format(notoriety_date, "%Y-%m-%d")), y = -0.2),
            vjust = 1, hjust = 0.5, size = 2.5, angle = 90, color = "red", na.rm = TRUE, check_overlap = TRUE) +

  # Customize appearance
  scale_x_date(date_breaks = "1 year", date_labels = "%Y",
               limits = c(min(timeline_data$release_date, na.rm = TRUE) - years(1), max(timeline_data$release_date, na.rm = TRUE) + years(1))) + # Extend x-axis slightly
  scale_y_continuous(limits = c(-0.5, 0.5), breaks = NULL) + # Adjust y-axis for labels and lines, hide breaks
  scale_shape_manual(values = c("Release Event" = 16, "Notoriety Event" = 17)) + # Circle for release, triangle for notoriety
  labs(title = paste0("Timeline for ", target_name, "'s Associated Releases & Events"),
       x = "Year",
       y = NULL,
       shape = "Event Type") + # Legend title for shapes
  theme_minimal() +
  theme(panel.grid.minor = element_blank(), # Remove minor grid lines
        panel.grid.major.y = element_blank(), # Remove major horizontal grid lines
        axis.text.x = element_text(angle = 45, hjust = 1),# Angle x-axis labels
        legend.position = "bottom") # Position legend at the bottom
```


## Questions

```         
-   Can see when she released songs and what these songs any linkage to other songs or people and influence - can determine who influence her most

    -   from current graphs

        -   lyricalreferenceto - drowned harbour

        -   instyleof - the fittle & the fjord

        -   directlysamples and has been a member of - Ivy Echos
```

-   when did she team up with or collaborate with or write songs for different persons or groups

-   History of collaboration and timestamp with those she has worked with

-   

##Approach data cleaning show full chart of sailor shift
